{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 HelveticaNeue-Bold;
\f3\fmodern\fcharset0 Courier;\f4\fmodern\fcharset0 Courier-Oblique;\f5\fmodern\fcharset0 Courier-Bold;
\f6\fnil\fcharset0 Menlo-Regular;\f7\fnil\fcharset0 HelveticaNeue;\f8\fnil\fcharset134 HiraginoSansGB-W3;
\f9\fnil\fcharset0 Menlo-Italic;}
{\colortbl;\red255\green255\blue255;\red25\green25\blue25;\red255\green255\blue255;\red0\green29\blue164;
\red10\green79\blue103;\red9\green9\blue9;\red18\green51\blue230;\red121\green121\blue121;\red114\green0\blue130;
\red251\green2\blue7;\red184\green93\blue213;\red30\green33\blue39;\red155\green162\blue177;\red222\green180\blue104;
\red81\green158\blue235;\red197\green136\blue84;\red74\green80\blue93;\red136\green185\blue102;\red203\green36\blue57;
\red91\green40\blue180;\red27\green31\blue35;\red218\green76\blue12;\red8\green68\blue184;\red87\green96\blue106;
\red17\green109\blue18;\red0\green0\blue255;\red255\green255\blue254;\red15\green112\blue1;\red19\green118\blue70;
\red29\green38\blue42;\red67\green91\blue103;\red245\green247\blue249;\red7\green33\blue79;\red142\green190\blue255;
\red12\green99\blue153;\red210\green50\blue85;\red135\green135\blue135;\red135\green91\blue44;\red255\green255\blue255;
\red133\green0\blue67;\red93\green108\blue125;\red32\green108\blue135;\red101\green76\blue29;\red0\green0\blue109;
\red157\green0\blue210;\red144\green1\blue18;\red0\green0\blue0;\red32\green108\blue135;\red101\green76\blue29;
\red0\green0\blue109;\red19\green118\blue70;\red15\green112\blue1;\red157\green0\blue210;}
{\*\expandedcolortbl;;\cssrgb\c12941\c12941\c12941;\cssrgb\c100000\c100000\c100000;\csgenericrgb\c0\c11373\c64314;
\csgenericrgb\c3922\c30980\c40392;\csgenericrgb\c3529\c3529\c3529;\csgenericrgb\c7059\c20000\c90196;\csgenericrgb\c47451\c47451\c47451;\csgenericrgb\c44706\c0\c50980;
\cssrgb\c100000\c14913\c0;\csgenericrgb\c72157\c36471\c83529;\csgenericrgb\c11765\c12941\c15294;\csgenericrgb\c60784\c63529\c69412;\csgenericrgb\c87059\c70588\c40784;
\csgenericrgb\c31765\c61961\c92157;\csgenericrgb\c77255\c53333\c32941;\csgenericrgb\c29020\c31373\c36471;\csgenericrgb\c53333\c72549\c40000;\csgenericrgb\c79608\c14118\c22353;
\csgenericrgb\c35686\c15686\c70588;\csgenericrgb\c10588\c12157\c13725;\csgenericrgb\c85490\c29804\c4706;\csgenericrgb\c3137\c26667\c72157;\csgenericrgb\c34118\c37647\c41569;
\csgenericrgb\c6667\c42745\c7059;\cssrgb\c0\c0\c100000;\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c50196\c0;\cssrgb\c3529\c52549\c34510;
\cssrgb\c14902\c19608\c21961;\cssrgb\c32941\c43137\c47843;\cssrgb\c96863\c97647\c98039;\csgenericrgb\c2745\c12941\c30980;\csgenericrgb\c55686\c74510\c100000;
\cssrgb\c0\c46667\c66667;\cssrgb\c86667\c29020\c40784;\cssrgb\c60000\c60000\c60000;\cssrgb\c60392\c43137\c22745;\cssrgb\c100000\c100000\c100000\c50196;
\cssrgb\c60000\c0\c33333;\cssrgb\c43922\c50196\c56471;\cssrgb\c14902\c49804\c60000;\cssrgb\c47451\c36863\c14902;\cssrgb\c0\c6275\c50196;
\cssrgb\c68627\c0\c85882;\cssrgb\c63922\c8235\c8235;\cssrgb\c0\c0\c0;\cssrgb\c14902\c49804\c60000;\cssrgb\c47451\c36863\c14902;
\cssrgb\c0\c6275\c50196;\cssrgb\c3529\c52549\c34510;\cssrgb\c0\c50196\c0;\cssrgb\c68627\c0\c85882;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid1\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww16620\viewh15180\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs72 \cf0 Java Answer
\f1\b0\fs24 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
3.\'a0Longest Substring Without Repeating Characters
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************\
\pard\pardeftab720\partightenfactor0

\f2\b\fs32 \cf2 \cb3 \expnd0\expndtw0\kerning0
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f3\b0 \cf4 \cb1 \kerning1\expnd0\expndtw0 public static int \cf5 lengthOfLongestSubstring\cf6 (\cf0 String \cf6 s) \{\
\
\
    \cf4 int \cf6 out = \cf7 0\cf6 ;\
    \cf0 List\cf6 <\cf0 String\cf6 > store = \cf4 new \cf6 ArrayList<\cf0 String\cf6 >();\
    \cf4 int \cf6 count = \cf7 0\cf6 ;
\f4\i \cf8 \
\
    
\f3\i0 \cf4 for\cf6 (\cf4 int \cf6 i=\cf7 0\cf6 ; i<s.length(); i++)\{
\f4\i \cf8 \
        
\f3\i0 \cf0 String curr \cf6 = \cf0 String\cf6 .
\f4\i valueOf
\f3\i0 (s.charAt(i));\
        \cf4 int \cf0 curr_index \cf6 = store.indexOf(\cf0 curr\cf6 );\
\
        \cf4 if\cf6 (!store.contains(\cf0 curr\cf6 ))\{\
            store.add(\cf0 curr\cf6 );\
            count++;\
            
\f4\i \cf8 //System.out.println("Count Value: " + count);\
        
\f3\i0 \cf6 \} \cf4 else \cf6 \{\
\
            \cf4 int \cf0 leftLength \cf6 = s.length() - \cf0 curr_index \cf6 + \cf7 1\cf6 ;\
            \cf4 if\cf6 (\cf0 leftLength \cf6 > count)\{\
                \cf4 if\cf6 (count > out)\{\
                    out = count;\
                \}\
\
                \cf4 if\cf6 (\cf0 curr_index \cf6 == store.size()-\cf7 1\cf6 )\{\
                    
\f4\i \cf8 // duplicated letter is the last one in the List\
                    
\f3\i0 \cf6 store = \cf4 new \cf6 ArrayList<\cf0 String\cf6 >();\
                    store.add(\cf0 curr\cf6 );\
                    count = \cf7 1\cf6 ;\
                \} \cf4 else \cf6 \{\
                    \cf4 for\cf6 (\cf4 int \cf6 j=\cf0 curr_index\cf6 ; j>=\cf7 0\cf6 ; j--)\{\
                        \cf0 System\cf6 .
\f4\i \cf9 out
\f3\i0 \cf6 .println(store.get(j));\
                        store.remove(j);\
                        count--;\
                    \}\
\
                    store.add(\cf0 curr\cf6 );\
                    count++;\
                \}\
            \} \cf4 else \cf6 \{\
                \cf4 break\cf6 ;\
            \}\
\
        \}\
\
    \}\
    
\f4\i \cf8 //System.out.println(store);\
    
\f3\i0 \cf4 return \cf6 (out > count) ? out : count;\
\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\fs26 \cf6 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 ************************************
\fs32 \cb10 sample answer
\fs28 \cb1 ************************************\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f3\fs26 \cf11 \cb12 import \cf13 java.util.*;\
        \cf11 import \cf13 java.lang.*;\
        \cf11 import \cf13 java.io.*;\
\cf11 class \cf14 Main \cf13 \{\
    \cf11 public int \cf15 lengthOfLongestSubstring\cf13 (\cf14 String \cf16 s\cf13 ) \{\
\
        \cf11 int \cf13 n = \cf16 s\cf13 .\cf15 length\cf13 ();\
\
        \cf11 int \cf13 res = \cf16 0\cf13 ;\
        \cf11 for \cf13 (\cf11 int \cf13 i = \cf16 0\cf13 ; i < n; i++) \{\
            \cf11 for \cf13 (\cf11 int \cf13 j = i; j < n; j++) \{\
                \cf11 if \cf13 (\cf15 checkRepetition\cf13 (\cf16 s\cf13 , i, j)) \{\
                    res = \cf14 Math\cf13 .\cf15 max\cf13 (res, j - i + \cf16 1\cf13 );\
                \}\
            \}\
        \}\
\
        \cf11 return \cf13 res;\
    \}\
\
    \cf11 private boolean \cf15 checkRepetition\cf13 (\cf14 String \cf16 s\cf13 , \cf11 int \cf16 start\cf13 , \cf11 int \cf16 end\cf13 ) \{\
        \cf11 int\cf13 [] chars = \cf11 new int\cf13 [\cf16 128\cf13 ];\
\
        \cf11 for \cf13 (\cf11 int \cf13 i = \cf16 start\cf13 ; i <= \cf16 end\cf13 ; i++) \{\
            \cf11 char \cf13 c = \cf16 s\cf13 .\cf15 charAt\cf13 (i);\
            chars[c]++;\
            \cf11 if \cf13 (chars[c] > \cf16 1\cf13 ) \{\
                \cf11 return false\cf13 ;\
            \}\
        \}\
        \cf11 return true\cf13 ;\
    \}\
    \cf11 public static void \cf15 main\cf13 (\cf14 String \cf16 args\cf13 []) \{\
        \cf17 // Your code goes here\
        \cf14 Main \cf13 ob = \cf11 new \cf14 Main\cf13 ();\
        \cf14 String \cf13 s = \cf18 "Hello"\cf13 ;\
        \cf14 System\cf13 .\cf16 out\cf13 .\cf15 println\cf13 (ob.\cf15 lengthOfLongestSubstring\cf13 (s));\
    \}\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs30 \cf0 \cb1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 ********************************************************************************************************\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f5\b\fs48 \cf2 \cb3 \expnd0\expndtw0\kerning0
4.\'a0Median of Two Sorted Array
\f2\fs36 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 ********************************************************************************************************
\f3\fs30 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf19 public static double \cf20 findMedianSortedArrays\cf21 (\cf19 int\cf21 [] \cf22 nums1\cf21 , \cf19 int\cf21 [] \cf22 nums2\cf21 ) \{\
    \cf19 int \cf23 m \cf19 = \cf22 nums1\cf21 .length;\
    \cf19 int \cf23 n \cf19 = \cf22 nums2\cf21 .length;\
    \cf19 int\cf21 [] \cf23 merged \cf19 = new int\cf21 [\cf23 m\cf19 +\cf23 n\cf21 ];\
\
    \cf19 for\cf21 (\cf19 int \cf23 i\cf19 =\cf23 0\cf21 , \cf23 j\cf19 =\cf23 0\cf21 , \cf23 k\cf19 =\cf23 0\cf21 ; \cf23 i\cf19 <\cf23 merged\cf21 .length;)\{\
        \cf19 while\cf21 (\cf23 j\cf19 <\cf23 m\cf21 )\{\
            \cf23 merged\cf21 [\cf23 i\cf21 ] \cf19 = \cf22 nums1\cf21 [\cf23 j\cf21 ];\
            \cf23 i\cf19 ++\cf21 ;\
            \cf23 j\cf19 ++\cf21 ;\
        \}\
\
        \cf19 while\cf21 (\cf23 k\cf19 <\cf23 n\cf21 )\{\
            \cf23 merged\cf21 [\cf23 i\cf21 ] \cf19 = \cf22 nums2\cf21 [\cf23 k\cf21 ];\
            \cf23 i\cf19 ++\cf21 ;\
            \cf23 k\cf19 ++\cf21 ;\
        \}\
    \}\
\
    \cf20 Arrays\cf21 .\cf20 sort\cf21 (\cf23 merged\cf21 );\cf24 \
\
    \cf19 double \cf23 median \cf19 = \cf23 merged\cf21 [\cf23 merged\cf21 .length\cf19 /\cf23 2\cf21 ];\cf24 \
    \cf19 if\cf21 ((\cf23 m\cf19 +\cf23 n\cf21 )\cf19 %\cf23 2 \cf19 == \cf23 0\cf21 )\{\
        \cf24 // Even case\
        \cf23 median \cf19 = \cf21 (\cf23 median \cf19 + \cf23 merged\cf21 [\cf23 merged\cf21 .length\cf19 /\cf23 2 \cf19 - \cf23 1\cf21 ]) \cf19 / \cf23 2\cf21 ;\
    \}\
\
    \cf19 return \cf23 median\cf21 ;\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs30 \cf0 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
5. 
\f5\fs48 \cf0 \cb1 \kerning1\expnd0\expndtw0 Longest Palindromic Substring
\f1\b0\fs28 \
********************************************************************************************************
\f3\fs30 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs32 \cf4 public class \cf0 LongestPalindromicSubstring \cf6 \{\
    \cf4 public static \cf0 String \cf5 longestPalindrome\cf6 (\cf0 String \cf6 s) \{\
        \cf8 //List<String> LeftToRight = new ArrayList<String>();\
        //List<String> RightToLeft = new ArrayList<String>();\
        \cf0 String\cf6 [] \cf0 front \cf6 = \cf4 new \cf6 String[s.length()];        \cf8 // Left to Right\
        \cf0 String\cf6 [] \cf0 back \cf6 = \cf4 new \cf6 String[s.length()];         \cf8 // Right to Left\
\
        \cf4 for\cf6 (\cf4 int \cf6 i=\cf7 0\cf6 , j=s.length()-\cf7 1\cf6 ; i<s.length(); i++, j--)\{\
            \cf0 front\cf6 [i] = \cf0 String\cf6 .valueOf(s.charAt(i));\
            \cf0 back\cf6 [i] = \cf0 String\cf6 .valueOf(s.charAt(j));\
        \}\
\
        \cf0 String \cf6 result = \cf25 ""\cf6 ;\
        \cf4 for\cf6 (\cf4 int \cf6 i=\cf7 0\cf6 ; i<\cf0 back\cf6 .\cf9 length\cf6 ; i++)\{\
            \cf0 StringBuilder current \cf6 = \cf4 new \cf6 StringBuilder();\
            \cf4 for\cf6 (\cf4 int \cf6 j=\cf7 0\cf6 ; j<\cf0 front\cf6 .\cf9 length\cf6 ; j++)\{\
\
                \cf8 //System.out.println(front[i] + "--" + back[j]);\
                //char curr_front = front[i].charAt(i);\
                //char curr_back = back[j].charAt(j);\
                \cf4 if\cf6 (i < \cf0 back\cf6 .\cf9 length \cf6 && \cf0 Objects\cf6 .equals(\cf0 back\cf6 [i], \cf0 front\cf6 [j]))\{\
                    \cf8 //System.out.println("Here!!");\
                    \cf0 current\cf6 .append(\cf0 front\cf6 [i]);\
                    i++;\
                \}\
            \}\
\
            \cf0 System\cf6 .\cf9 out\cf6 .println(i);\
            \cf4 if\cf6 (\cf0 current\cf6 .length() > result.length())\{\
                result = \cf0 current\cf6 .toString();\
            \}\
\
        \}\
\
        \cf0 System\cf6 .\cf9 out\cf6 .println(result);\
        \cf4 return \cf0 Arrays\cf6 .toString(\cf0 back\cf6 );\
    \}\
    \cf4 public static void \cf5 main\cf6 (\cf0 String\cf6 [] args) \{\
\
        \cf0 String wd \cf6 = \cf25 "fkayakd"\cf6 ;\
\
        \cf0 System\cf6 .\cf9 out\cf6 .println(longestPalindrome(\cf25 "babad"\cf6 ));\
\
        \cf8 //System.out.println(wd.charAt(0));\
    \cf6 \}\
\}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 ************************************
\fs32 \cb10 sample answer
\fs28 \cb1 ************************************ 
\f3\fs32 \cf6 \
\
\pard\pardeftab720\partightenfactor0

\f6\fs28 \cf26 \cb27 \expnd0\expndtw0\kerning0
public\cf0  \cf26 static\cf0  \cf26 int\cf0  longestPalSubstr(String str)\cb1 \
\cb27     \{\cb1 \
\cb27         \cf28 // get length of input String\cf0 \cb1 \
\cb27         \cf26 int\cf0  n = str.length();\cb1 \
\cb27     \cb1 \
\cb27         \cf28 // All subStrings of length 1\cf0 \cb1 \
\cb27         \cf28 // are palindromes\cf0 \cb1 \
\cb27         \cf26 int\cf0  maxLength = \cf29 1\cf0 , start = \cf29 0\cf0 ;\cb1 \
\cb27     \cb1 \
\cb27         \cf28 // Nested loop to mark start and end index\cf0 \cb1 \
\cb27         \cf26 for\cf0  (\cf26 int\cf0  i = \cf29 0\cf0 ; i < str.length(); i++) \{\cb1 \
\cb27             \cf26 for\cf0  (\cf26 int\cf0  j = i; j < str.length(); j++) \{\cb1 \
\cb27                 \cf26 int\cf0  flag = \cf29 1\cf0 ;\cb1 \
\cb27     \cb1 \
\cb27                 \cf28 // Check palindrome\cf0 \cb1 \
\cb27                 \cf26 for\cf0  (\cf26 int\cf0  k = \cf29 0\cf0 ; k < (j - i + \cf29 1\cf0 ) / \cf29 2\cf0 ; k++)\cb1 \
\cb27                     \cf26 if\cf0  (str.charAt(i + k) != str.charAt(j - k))\cb1 \
\cb27                         flag = \cf29 0\cf0 ;\cb1 \
\cb27     \cb1 \
\cb27                 \cf28 // Palindrome\cf0 \cb1 \
\cb27                 \cf26 if\cf0  (flag!=\cf29 0\cf0  && (j - i + \cf29 1\cf0 ) > maxLength) \{\cb1 \
\cb27                     start = i;\cb1 \
\cb27                     maxLength = j - i + \cf29 1\cf0 ;\cb1 \
\cb27                 \}\cb1 \
\cb27             \}\cb1 \
\cb27         \}\cb1 \
\cb27     \cb1 \
\cb27         \cf28 // return length of LPS\cf0 \cb1 \
\cb27         \cf26 return\cf0  maxLength;\cb1 \
\cb27     \}\cb1 \
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 \kerning1\expnd0\expndtw0 ********************************************************************************************************\
\pard\pardeftab720\partightenfactor0

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
6.\'a0Zigzag Conversion
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 ********************************************************************************************************\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f3\fs32 \cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs26 \cf4 public static \cf0 String \cf5 convert\cf6 (\cf0 String \cf6 s, \cf4 int \cf6 numRows) \{\
    \cf0 String\cf6 [] \cf0 output \cf6 = \cf4 new \cf6 String[numRows];\
    \cf4 int \cf6 count = \cf7 0\cf6 ; 
\f4\i \cf8 // < numRows\
\
    
\f3\i0 \cf4 for\cf6 (\cf4 int \cf6 i=\cf7 0\cf6 ; i<numRows; i++)\{\
        \cf0 output\cf6 [i] = \cf25 ""\cf6 ;\
    \}\
\
    \cf4 for\cf6 (\cf4 int \cf6 i=\cf7 0\cf6 ; i<s.length(); i++)\{\
        \cf0 output \cf6 [count] += \cf0 String\cf6 .
\f4\i valueOf
\f3\i0 (s.charAt(i));\
        count++;    
\f4\i \cf8 // 0 -> numRows-1\
\
        // middle case\
        
\f3\i0 \cf4 if\cf6 (count == numRows && numRows > \cf7 2\cf6 )\{\
            count = \cf7 0\cf6 ;\
            \cf4 int \cf6 num = numRows/\cf7 2\cf6 ;\
            \cf4 for\cf6 (;num>\cf7 0\cf6 ; num--)\{\
                i++;\
                \cf0 output \cf6 [num] += \cf0 String\cf6 .
\f4\i valueOf
\f3\i0 (s.charAt(i));\
            \}\
            
\f4\i \cf8 //i = i + (numRows/2);\
        
\f3\i0 \cf6 \} \cf4 else if\cf6 (count == numRows)\{\
            count = \cf7 0\cf6 ;\
        \};\
    \}\
\
    \cf0 String str \cf6 = \cf0 String\cf6 .
\f4\i join
\f3\i0 (\cf25 ""\cf6 ,\cf0 output\cf6 );
\f4\i \cf8 \
    
\f3\i0 \cf4 return \cf0 str\cf6 ;\
\}\
\
************
\f5\b\fs36 Method 2
\f3\b0\fs26 ************\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf4 public static \cf0 String \cf5 convert2\cf6 (\cf0 String \cf6 s, \cf4 int \cf6 numRows)\{\
    \cf0 String\cf6 [] \cf0 output \cf6 = \cf4 new \cf6 String[numRows];\
\
    \cf4 if\cf6 (numRows <= \cf7 1 \cf6 || numRows >= s.length())\
        \cf4 return \cf6 s;\
\
    \cf4 for\cf6 (\cf4 int \cf6 i=\cf7 0\cf6 ; i<numRows; i++)\{\
        \cf0 output\cf6 [i] = \cf25 ""\cf6 ;\
    \}\
\
    \cf4 for\cf6 (\cf4 int \cf6 i=\cf7 0\cf6 , j=\cf7 0\cf6 ; i<s.length(); i++)\{\
\
        \cf4 if\cf6 (j==(numRows-\cf7 1\cf6 ))\{\
            \cf8 //System.out.println(s.charAt(i));\
            \cf0 output \cf6 [j] += \cf0 String\cf6 .valueOf(s.charAt(i));\
            \cf0 System\cf6 .\cf9 out\cf6 .println(j + \cf25 "-" \cf6 + s.charAt(i));\
            j--;\
            \cf8 //System.out.println(s.charAt(i));\
            \cf4 while\cf6 (j!=\cf7 0\cf6 )\{\
                i++;\
                \cf8 //System.out.println(i);\
                \cf4 if\cf6 (i >= s.length()) \{\
                    \cf4 break\cf6 ;\
                \}\
                \cf0 output \cf6 [j] += \cf0 String\cf6 .valueOf(s.charAt(i));\
                j--;\
            \}\
\
        \} \cf4 else\cf6 \{\
            \cf0 System\cf6 .\cf9 out\cf6 .println(j + \cf25 "-" \cf6 + s.charAt(i));\
            \cf0 output \cf6 [j] += \cf0 String\cf6 .valueOf(s.charAt(i));\
            j++;\
        \}\
\
    \}\
\
    \cf0 String str \cf6 = \cf0 String\cf6 .join(\cf25 ""\cf6 ,\cf0 output\cf6 );\
    \cf4 return \cf0 str\cf6 ;\
    \cf8 //return Arrays.toString(output);\
\cf6 \}\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
7.\'a0Reverse Integer
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f3 \cf6 \
public static int reverseInt(int x) \{\
        ArrayList<Integer> num = new ArrayList<Integer>();\
        int copyX = (x < 0) ? -x : x;\
        int output = 0;\
\
        // get digit of x\
        while(copyX > 0)\{\
            int remain = copyX % 10;\
            num.add(remain);\
            copyX = copyX / 10;\
        \}\
\
        int pow = num.size() - 1;\
        for (Integer integer : num) \{\
            output += integer * Math.pow(10, pow);\
            pow--;\
        \}\
\
        if(output == 2147483647 || output ==-2147483648)\
            return 0;\
\
        return (x < 0) ? -output : output;\
    \}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs26 \cf6 ************
\f5\b\fs36 Method 2 (Update from above)
\f3\b0\fs26 ************\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf6 \
public static int reverseInt2(int x)\{\
        //ArrayList<Integer> num = new ArrayList<Integer>();\
        int copyX = (x < 0) ? -x : x;\
        int output = 0, digit = 0;\
\
        // get digit of x\
        while(copyX > 0)\{\
            copyX = copyX / 10;\
            digit++;\
        \}\
\
        copyX = (x < 0) ? -x : x;\
        for(int i=digit-1; i>=0; i--)\{\
            output += (copyX%10) * Math.pow(10,i);\
            copyX = copyX / 10;\
        \}\
\
        if(output == 2147483647 || output ==-2147483648)\
            return 0;\
\
        return (x < 0) ? -output : output;\
    \}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs26 \cf6 ************
\f5\b\fs36 Method 3 (Update from above)
\f3\b0\fs26 ************\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf6 public static int reverseInt2(int x)\{\
	int output = 0;\
\
	while(x != 0)\{\
		int remain = x % 10;\
		x /= 10;\
		if(output > Integer.MAX_VALUE/10 || output < Integer.MIN_VALUE/10) return 0;\
		output = output * 10 + remain;\
	\}\
\
	return output;\
\}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs26 \cf6 ************
\f5\b\fs36 Sample
\f3\b0\fs26 ************
\fs28 \
public static int reverseInt3(int x) \{\
        int rev = 0;\
        while (x != 0) \{\
            int pop = x % 10;		// remainder\
            x /= 10;\
            if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;\
            if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;\
            rev = rev * 10 + pop;\
            System.out.println("pop: " + pop + ", rev: " + rev );\
        \}\
        return rev;\
    \}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
8.\'a0String to Integer\
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\f7\b0\fs28 \cf30 \kerning1\expnd0\expndtw0 1	\expnd0\expndtw0\kerning0
Read in and ignore any leading whitespace.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	2	}\expnd0\expndtw0\kerning0
Check if the next character (if not already at the end of the string) is\'a0
\f3\fs26 \cf31 \cb32 '-'
\f7\fs28 \cf30 \cb3 \'a0or\'a0
\f3\fs26 \cf31 \cb32 '+'
\f7\fs28 \cf30 \cb3 . Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	3	}\expnd0\expndtw0\kerning0
Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	4	}\expnd0\expndtw0\kerning0
Convert these digits into an integer (i.e.\'a0
\f3\fs26 \cf31 \cb32 "123" -> 123
\f7\fs28 \cf30 \cb3 ,\'a0
\f3\fs26 \cf31 \cb32 "0032" -> 32
\f7\fs28 \cf30 \cb3 ). If no digits were read, then the integer is\'a0
\f3\fs26 \cf31 \cb32 0
\f7\fs28 \cf30 \cb3 . Change the sign as necessary (from step 2).\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	5	}\expnd0\expndtw0\kerning0
If the integer is out of the 32-bit signed integer range\'a0
\f3\fs26 \cf31 \cb32 [-2
\fs19\fsmilli9750 31
\fs26 , 2
\fs19\fsmilli9750 31
\fs26 \'a0- 1]
\f7\fs28 \cf30 \cb3 , then clamp the integer so that it remains in the range. Specifically, integers less than\'a0
\f3\fs26 \cf31 \cb32 -2
\fs19\fsmilli9750 31
\f7\fs28 \cf30 \cb3 \'a0should be clamped to\'a0
\f3\fs26 \cf31 \cb32 -2
\fs19\fsmilli9750 31
\f7\fs28 \cf30 \cb3 , and integers greater than\'a0
\f3\fs26 \cf31 \cb32 2
\fs19\fsmilli9750 31
\fs26 \'a0- 1
\f7\fs28 \cf30 \cb3 \'a0should be clamped to\'a0
\f3\fs26 \cf31 \cb32 2
\fs19\fsmilli9750 31
\fs26 \'a0- 1
\f7\fs28 \cf30 \cb3 .\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	6	}\expnd0\expndtw0\kerning0
Return the integer as the final result.\cb1 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural\partightenfactor0

\f3\fs27 \cf21 \kerning1\expnd0\expndtw0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \
********************************************************************************************************\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f3 \cf0 // Wrong Answer\
public static int myAtoi(String s) \{\
        int atoi = 0;\
        int sign = 1;\
\
        for(int i=0; i<s.length(); i++)\{\
            //System.out.println(s.charAt(i));\
            String rn = String.valueOf(s.charAt(i));\
            if(rn.compareTo("-") == 0)\{\
                sign = -1;\
                //System.out.println("Signal at " + i);\
            \}\
\
            int check = -1;\
            for(int j=0; j<=9; j++)\{\
                //System.out.println(s.charAt(i) + ":" +\
                String jString = String.valueOf(j);\
                if(rn.equals(jString)) \{\
                    check = j;\
                    //System.out.println(check + ", i: " + s.charAt(i) + ", j" + j);\
                    break;\
                \}\
            \}\
\
            if(check != -1) \{\
                //System.out.println(check + "; atoi= " + atoi);\
                atoi = (atoi == 0) ? (check) : (atoi * 10 + check);\
                //System.out.println(atoi);\
            \}\
        \}\
        return (sign == 1) ? atoi : atoi * -1;\
    \}\
\
\
****\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf19 private static final int 
\f4\i \cf23 maxDiv10 
\f3\i0 \cf19 = \cf20 Integer\cf21 .
\f4\i \cf23 MAX_VALUE 
\f3\i0 \cf19 / \cf23 10\cf21 ;\
\cf19 public static int \cf20 myAtoiSample1\cf21 (\cf20 String \cf22 s\cf21 ) \{\
    \cf19 if \cf21 (\cf22 s \cf19 == \cf23 null\cf21 ) \cf19 return \cf23 0\cf21 ;\
    \cf19 int \cf23 n \cf19 = \cf22 s\cf21 .\cf20 length\cf21 ();\
    \cf19 if \cf21 (\cf23 n \cf19 == \cf23 0\cf21 ) \cf19 return \cf23 0\cf21 ;\
    \cf19 int \cf23 i \cf19 = \cf23 0\cf21 ;\
\
    \cf24 // skip all the ' ' (space) within the front of s\
    // exit while loop with new i value\
    \cf19 while \cf21 (\cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 == \cf33 ' '\cf21 ) \{\
        \cf24 // 
\f8 \'bd\'f6\'b0\'fc\'ba\'ac\'bf\'d5\'b8\'f1
\f3 \
        \cf19 if \cf21 (\cf19 ++\cf23 i \cf19 == \cf23 n\cf21 ) \cf19 return \cf23 0\cf21 ;\
        \cf24 //System.out.println(i);\
    \cf21 \}\
    \cf20 System\cf21 .
\f4\i \cf23 out
\f3\i0 \cf21 .\cf20 println\cf21 (\cf33 "Right Now: " \cf19 + \cf22 s\cf21 );\
\
    \cf19 int \cf23 sign \cf19 = \cf23 1\cf21 ;\
    \cf24 // 2 or more of '-' or '+' next to each : return 0;\
    \cf19 if \cf21 (\cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 == \cf33 '-'\cf21 ) \cf23 sign \cf19 = -\cf23 1\cf21 ;                      \cf24 // if s is negative value\
    \cf19 if \cf21 (\cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 == \cf33 '-' \cf19 || \cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 == \cf33 '+'\cf21 ) \cf19 ++\cf23 i\cf21 ;      \cf24 // update i if there is '+' or '-'\
    \cf19 int \cf23 res \cf19 = \cf23 0\cf21 , \cf23 flag \cf19 = \cf20 Integer\cf21 .
\f4\i \cf23 MAX_VALUE 
\f3\i0 \cf19 / \cf23 10\cf21 ;\
\
    \cf19 for \cf21 (; \cf23 i \cf19 < \cf23 n\cf21 ; \cf19 ++\cf23 i\cf21 ) \{\
        \cf24 // when detect non-numeric,, break\
        \cf19 if \cf21 (\cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 < \cf33 '0' \cf19 || \cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 > \cf33 '9'\cf21 ) \cf19 break\cf21 ;\
        \cf20 System\cf21 .
\f4\i \cf23 out
\f3\i0 \cf21 .\cf20 println\cf21 (\cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ));\
        \cf24 // check overflow\
        \cf19 if \cf21 (\cf23 res \cf19 > \cf23 flag \cf19 || \cf21 (\cf23 res \cf19 == \cf23 flag \cf19 && \cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 > \cf33 '7'\cf21 ))\
            \cf19 return \cf23 sign \cf19 > \cf23 0 \cf19 ? \cf20 Integer\cf21 .
\f4\i \cf23 MAX_VALUE 
\f3\i0 \cf19 : \cf20 Integer\cf21 .
\f4\i \cf23 MIN_VALUE
\f3\i0 \cf21 ;\
        \cf23 res \cf19 = \cf23 res \cf19 * \cf23 10 \cf19 + \cf21 (\cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 - \cf33 '0'\cf21 );\
\
    \}\
    \cf19 return \cf23 sign \cf19 * \cf23 res\cf21 ;\
\}\
*****\
\cf19 private static final int \cf23 maxDiv10 \cf19 = \cf20 Integer\cf21 .\cf23 MAX_VALUE \cf19 / \cf23 10\cf21 ;\cf24 \
\cf19 public static int \cf20 myAtoi5\cf21 (\cf20 String \cf22 str\cf21 ) \{\
    \cf19 int \cf23 i \cf19 = \cf23 0\cf21 , \cf23 n \cf19 = \cf22 str\cf21 .\cf20 length\cf21 ();\
    \cf19 while \cf21 (\cf23 i \cf19 < \cf23 n \cf19 && \cf20 Character\cf21 .\cf20 isWhitespace\cf21 (\cf22 str\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 )))\
        \cf23 i\cf19 ++\cf21 ;\
\
    \cf19 int \cf23 sign \cf19 = \cf23 1\cf21 ;\
    \cf19 if \cf21 (\cf23 i \cf19 < \cf23 n \cf19 && \cf22 str\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 == \cf33 '+'\cf21 )\
        \cf23 i\cf19 ++\cf21 ;\
    \cf19 else if \cf21 (\cf23 i \cf19 < \cf23 n \cf19 && \cf22 str\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 == \cf33 '-'\cf21 ) \{\
        \cf23 sign \cf19 = -\cf23 1\cf21 ;\
        \cf23 i\cf19 ++\cf21 ;\
    \}\
\
    \cf19 int \cf23 num \cf19 = \cf23 0\cf21 ;\
    \cf19 while \cf21 (\cf23 i \cf19 < \cf23 n \cf19 && \cf20 Character\cf21 .\cf20 isDigit\cf21 (\cf22 str\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ))) \{\
        \cf20 System\cf21 .\cf23 out\cf21 .\cf20 println\cf21 (\cf20 Character\cf21 .\cf20 getNumericValue\cf21 (\cf22 str\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 )));\
        \cf19 int \cf23 digit \cf19 = \cf20 Character\cf21 .\cf20 getNumericValue\cf21 (\cf22 str\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ));\
        \cf19 if \cf21 (\cf23 num \cf19 > \cf23 maxDiv10 \cf19 || \cf23 num \cf19 == \cf23 maxDiv10 \cf19 && \cf23 digit \cf19 >= \cf23 8\cf21 )\
            \cf19 return \cf23 sign \cf19 == \cf23 1 \cf19 ? \cf20 Integer\cf21 .\cf23 MAX_VALUE \cf19 : \cf20 Integer\cf21 .\cf23 MIN_VALUE\cf21 ;\
        \cf23 num \cf19 = \cf23 num \cf19 * \cf23 10 \cf19 + \cf23 digit\cf21 ;\
        \cf23 i\cf19 ++\cf21 ;\
    \}\
    \cf19 return \cf23 sign \cf19 * \cf23 num\cf21 ;\
\}
\f6\fs24 \

\f3\fs28 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
9.\'a0Palindrome Number
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f3\fs26 \cf19 public static boolean \cf20 isPalindrome\cf21 (\cf19 int \cf22 x\cf21 ) \{\
    \cf19 if\cf21 (\cf22 x \cf19 < \cf23 0\cf21 ) \cf19 return \cf23 false\cf21 ;\
\
    \cf19 int \cf23 reverse \cf19 = \cf23 0\cf21 , \cf23 copyX \cf19 = \cf22 x\cf21 ;\
\
    \cf19 while\cf21 (\cf23 copyX \cf19 > \cf23 0\cf21 )\{\
        \cf23 reverse \cf19 = \cf21 (\cf23 reverse \cf19 * \cf23 10\cf21 ) \cf19 + \cf21 (\cf23 copyX \cf19 % \cf23 10\cf21 );\
        \cf23 copyX \cf19 /= \cf23 10\cf21 ;\
    \}\
\
    \cf19 if\cf21 (\cf23 reverse \cf19 != \cf22 x\cf21 )\
        \cf19 return \cf23 false\cf21 ;\
    \cf19 else\
        return \cf23 true\cf21 ;\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf21 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
10.\'a0Regular Expression Matching
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f3 \cf21 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf19 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs26 \cf6 ************
\f5\b\fs36 Sample
\f3\b0\fs26 ************
\fs28 \cf19 \
public boolean \cf20 isMatch\cf21 (\cf20 String \cf22 s\cf21 , \cf20 String \cf22 p\cf21 ) \{\
    \cf19 int \cf23 m \cf19 = \cf22 s\cf21 .\cf20 length\cf21 (), \cf23 n \cf19 = \cf22 p\cf21 .\cf20 length\cf21 ();\
    \cf19 if \cf21 (\cf23 n \cf19 == \cf23 0\cf21 ) \{\
        \cf19 return \cf23 m \cf19 == \cf23 0\cf21 ;\
    \}\
    \cf19 boolean\cf21 [][] \cf23 dp \cf19 = new boolean\cf21 [\cf23 m \cf19 + \cf23 1\cf21 ][\cf23 n \cf19 + \cf23 1\cf21 ];\
    \cf23 dp\cf21 [\cf23 0\cf21 ][\cf23 0\cf21 ] \cf19 = true\cf21 ;\
    \cf19 for \cf21 (\cf19 int \cf23 j \cf19 = \cf23 1\cf21 ; \cf23 j \cf19 < \cf23 n \cf19 + \cf23 1\cf21 ; \cf19 ++\cf23 j\cf21 ) \{\
        \cf19 if \cf21 (\cf22 p\cf21 .\cf20 charAt\cf21 (\cf23 j \cf19 - \cf23 1\cf21 ) \cf19 == \cf33 '*'\cf21 ) \{\
            \cf23 dp\cf21 [\cf23 0\cf21 ][\cf23 j\cf21 ] \cf19 = \cf23 dp\cf21 [\cf23 0\cf21 ][\cf23 j \cf19 - \cf23 2\cf21 ];\
        \}\
    \}\
    \cf19 for \cf21 (\cf19 int \cf23 i \cf19 = \cf23 1\cf21 ; \cf23 i \cf19 < \cf23 m \cf19 + \cf23 1\cf21 ; \cf19 ++\cf23 i\cf21 ) \{\
        \cf19 for \cf21 (\cf19 int \cf23 j \cf19 = \cf23 1\cf21 ; \cf23 j \cf19 < \cf23 n \cf19 + \cf23 1\cf21 ; \cf19 ++\cf23 j\cf21 ) \{\
            \cf19 if \cf21 (\cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i \cf19 - \cf23 1\cf21 ) \cf19 == \cf22 p\cf21 .\cf20 charAt\cf21 (\cf23 j \cf19 - \cf23 1\cf21 ) \cf19 || \cf22 p\cf21 .\cf20 charAt\cf21 (\cf23 j \cf19 - \cf23 1\cf21 ) \cf19 == \cf33 '.'\cf21 ) \{\
                \cf23 dp\cf21 [\cf23 i\cf21 ][\cf23 j\cf21 ] \cf19 = \cf23 dp\cf21 [\cf23 i \cf19 - \cf23 1\cf21 ][\cf23 j \cf19 - \cf23 1\cf21 ];\
            \} \cf19 else if \cf21 (\cf22 p\cf21 .\cf20 charAt\cf21 (\cf23 j \cf19 - \cf23 1\cf21 ) \cf19 == \cf33 '*'\cf21 ) \{\
                \cf19 if \cf21 (\cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i \cf19 - \cf23 1\cf21 ) \cf19 == \cf22 p\cf21 .\cf20 charAt\cf21 (\cf23 j \cf19 - \cf23 2\cf21 ) \cf19 || \cf22 p\cf21 .\cf20 charAt\cf21 (\cf23 j \cf19 - \cf23 2\cf21 ) \cf19 == \cf33 '.'\cf21 ) \{\
                    \cf23 dp\cf21 [\cf23 i\cf21 ][\cf23 j\cf21 ] \cf19 = \cf23 dp\cf21 [\cf23 i\cf21 ][\cf23 j \cf19 - \cf23 2\cf21 ] \cf19 || \cf23 dp\cf21 [\cf23 i \cf19 - \cf23 1\cf21 ][\cf23 j\cf21 ];\
                \} \cf19 else \cf21 \{\
                    \cf23 dp\cf21 [\cf23 i\cf21 ][\cf23 j\cf21 ] \cf19 = \cf23 dp\cf21 [\cf23 i\cf21 ][\cf23 j \cf19 - \cf23 2\cf21 ];\
                \}\
            \}\
        \}\
    \}\
    \cf19 return \cf23 dp\cf21 [\cf23 m\cf21 ][\cf23 n\cf21 ];\
\}\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
11.\'a0Container with most water
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************\
\
\
\
********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
12.\'a0Integer to Roman
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f3\b0\fs30 \cf19 \cb1 \kerning1\expnd0\expndtw0 static public \cf20 String intToRoman\cf21 (\cf19 int \cf22 num\cf21 ) \{\
    \cf19 int\cf21 [] \cf23 n \cf19 = \cf21 \{\cf23 1\cf21 , \cf23 5\cf21 , \cf23 10\cf21 , \cf23 50\cf21 , \cf23 100\cf21 , \cf23 500\cf21 , \cf23 1000\cf21 \};\
    \cf20 String\cf21 [] \cf23 sym \cf19 = \cf21 \{\cf33 "I"\cf21 , \cf33 "V"\cf21 , \cf33 "X"\cf21 , \cf33 "L"\cf21 , \cf33 "C"\cf21 , \cf33 "D"\cf21 , \cf33 "M"\cf21 \};\
    \cf20 String \cf23 res \cf19 = \cf33 ""\cf21 ;\
\
    \cf19 while \cf21 (\cf22 num \cf19 > \cf23 0\cf21 ) \{\
        \cf19 int \cf23 digit \cf19 = \cf20 countDigit\cf21 (\cf22 num\cf21 );    \cf24 // count digit of num\
        \cf19 int \cf23 divideResult \cf19 = \cf21 (\cf19 int\cf21 ) (\cf22 num \cf19 / \cf20 Math\cf21 .\cf20 pow\cf21 (\cf23 10\cf21 , \cf23 digit\cf21 ));   \cf24 // first single digit (from left) to consider\
\
        \cf19 if\cf21 (\cf23 divideResult \cf19 == \cf23 4 \cf19 && \cf23 digit \cf19 < \cf23 3\cf21 ) \{\
            \cf24 // Digit from the leftest is 4\
            \cf22 num \cf19 -= \cf21 (\cf23 4 \cf19 * \cf20 Math\cf21 .\cf20 pow\cf21 (\cf23 10\cf21 ,\cf20 countDigit\cf21 (\cf22 num\cf21 ))) ;\
            \cf19 switch \cf21 (\cf23 digit\cf21 ) \{\
                \cf19 case \cf23 0\cf19 :\
                    \cf23 res \cf19 += \cf33 "IV"\cf21 ;\
                    \cf19 break\cf21 ;\
                \cf19 case \cf23 1\cf19 :\
                    \cf23 res \cf19 += \cf33 "XL"\cf21 ;\
                    \cf19 break\cf21 ;\
                \cf19 case \cf23 2\cf19 :\
                    \cf23 res \cf19 += \cf33 "CD"\cf21 ;\
                    \cf19 break\cf21 ;\
            \}\
\
        \} \cf19 else if\cf21 (\cf23 divideResult \cf19 == \cf23 9 \cf19 && \cf23 digit \cf19 < \cf23 3\cf21 ) \{\
            \cf24 // Digit from the leftest is 9\
            // If digit > 3, use 1000('M') case\
            \cf22 num \cf19 -= \cf21 (\cf23 9 \cf19 * \cf20 Math\cf21 .\cf20 pow\cf21 (\cf23 10\cf21 ,\cf20 countDigit\cf21 (\cf22 num\cf21 )));\
            \cf19 switch \cf21 (\cf23 digit\cf21 ) \{\
                \cf19 case \cf23 0\cf19 :\
                    \cf23 res \cf19 += \cf33 "IX"\cf21 ;\
                    \cf19 break\cf21 ;\
                \cf19 case \cf23 1\cf19 :\
                    \cf23 res \cf19 += \cf33 "XC"\cf21 ;\
                    \cf19 break\cf21 ;\
                \cf19 case \cf23 2\cf19 :\
                    \cf23 res \cf19 += \cf33 "CM"\cf21 ;\
                    \cf19 break\cf21 ;\
            \}\
        \} \cf19 else \cf21 \{\
            \cf24 // Others than 4 & 9 digit and 1000+ number\
            \cf19 int \cf23 realNumber \cf19 = \cf21 (\cf19 int\cf21 ) (\cf23 divideResult \cf19 *  \cf20 Math\cf21 .\cf20 pow\cf21 (\cf23 10\cf21 , \cf23 digit\cf21 ));   \cf24 // get the real number\
            \cf22 num \cf19 -= \cf23 realNumber\cf21 ;  \cf24 // subtract the original one. When num=0, program ends\
            \cf20 System\cf21 .\cf23 out\cf21 .\cf20 println\cf21 (\cf33 "**" \cf19 + \cf23 realNumber\cf21 );\
\
            \cf19 for\cf21 (\cf19 int \cf23 i\cf19 =\cf23 0\cf21 ; \cf23 i\cf19 <\cf23 n\cf21 .length \cf19 && \cf23 realNumber\cf19 !=\cf23 0\cf21 ; \cf23 i\cf19 ++\cf21 ) \{\
                \cf19 if\cf21 (\cf23 realNumber \cf19 == \cf23 n\cf21 [\cf23 i\cf21 ]) \{\
                    \cf23 res \cf19 += \cf23 sym\cf21 [\cf23 i\cf21 ];\
                    \cf19 break\cf21 ;\
                \}\
\
                \cf19 if\cf21 (\cf23 i \cf19 != \cf23 n\cf21 .length\cf19 -\cf23 1 \cf19 && \cf23 realNumber \cf19 > \cf23 n\cf21 [\cf23 i\cf21 ] \cf19 && \cf23 realNumber \cf19 < \cf23 n\cf21 [\cf23 i\cf19 +\cf23 1\cf21 ]) \{\
                    \cf19 while\cf21 (\cf23 realNumber \cf19 > \cf23 0\cf21 ) \{\
                        \cf23 res \cf19 += \cf23 sym\cf21 [\cf23 i\cf21 ];\
                        \cf23 realNumber \cf19 -= \cf23 n\cf21 [\cf23 i\cf21 ];\
                        \cf19 if\cf21 (\cf23 realNumber \cf19 < \cf23 n\cf21 [\cf23 i\cf21 ])\
                            \cf23 i\cf19 --\cf21 ;\
                    \}\
                \}\
\
                \cf19 if\cf21 (\cf23 i \cf19 == \cf23 n\cf21 .length\cf19 -\cf23 1 \cf19 && \cf23 digit \cf19 >= \cf23 3\cf21 ) \{\
                    \cf23 realNumber \cf19 -= \cf21 (\cf23 n\cf21 [\cf23 i\cf21 ] \cf19 * \cf23 divideResult\cf21 );\
                    \cf19 while\cf21 (\cf23 divideResult \cf19 != \cf23 0\cf21 ) \{\
                        \cf23 res \cf19 += \cf23 sym\cf21 [\cf23 i\cf21 ];\
                        \cf23 divideResult\cf19 --\cf21 ;\
                    \}\
                    \cf23 i\cf19 ++\cf21 ;\
                \}\
            \}\
        \}\
    \}\
    \cf19 return \cf23 res\cf21 ;\
\}\
\cf19 static public int \cf20 countDigit\cf21 (\cf19 int \cf22 num\cf21 ) \{\
    \cf19 int \cf23 digit \cf19 = \cf23 0\cf21 ;\
    \cf19 while\cf21 (\cf22 num\cf19 >\cf23 0\cf21 ) \{\
        \cf23 digit\cf19 ++\cf21 ;\
        \cf22 num \cf19 /= \cf23 10\cf21 ;\
    \}\
\
    \cf19 return \cf23 digit\cf19 -\cf23 1\cf21 ;\
\}
\fs26 \cf6 \
\
************
\f5\b\fs36 Sample
\f3\b0\fs26 ************
\fs30 \cf21 \
\
\cf19 public static \cf20 String intToRoman_Sample1\cf21 (\cf19 int \cf22 num\cf21 ) \{\
    \cf20 Map\cf19 <\cf20 Integer\cf21 , \cf20 String\cf19 > \cf23 map \cf19 = new \cf20 HashMap\cf21 ();\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 1\cf21 , \cf33 "I"\cf21 );\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 5\cf21 , \cf33 "V"\cf21 );\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 10\cf21 , \cf33 "X"\cf21 );\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 50\cf21 , \cf33 "L"\cf21 );\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 100\cf21 , \cf33 "C"\cf21 );\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 500\cf21 , \cf33 "D"\cf21 );\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 1000\cf21 , \cf33 "M"\cf21 );\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 4\cf21 , \cf33 "IV"\cf21 );\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 9\cf21 , \cf33 "IX"\cf21 );\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 40\cf21 , \cf33 "XL"\cf21 );\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 90\cf21 , \cf33 "XC"\cf21 );\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 400\cf21 , \cf33 "CD"\cf21 );\
    \cf23 map\cf21 .\cf20 put\cf21 (\cf23 900\cf21 , \cf33 "CM"\cf21 );\
\
    \cf19 int\cf21 [] \cf23 sequence \cf19 = \cf21 \{\cf23 1000\cf21 , \cf23 900\cf21 , \cf23 500\cf21 , \cf23 400\cf21 , \cf23 100\cf21 , \cf23 90\cf21 , \cf23 50\cf21 , \cf23 40\cf21 , \cf23 10\cf21 , \cf23 9\cf21 , \cf23 5\cf21 , \cf23 4\cf21 , \cf23 1\cf21 \};\
\
    \cf20 StringBuffer \cf23 sb \cf19 = new \cf20 StringBuffer\cf21 ();\
    \cf19 for \cf21 (\cf19 int \cf23 i \cf19 = \cf23 0\cf21 ; \cf23 i\cf19 <\cf23 sequence\cf21 .length; \cf23 i\cf19 ++\cf21 ) \{\
        \cf19 int \cf23 base \cf19 = \cf23 sequence\cf21 [\cf23 i\cf21 ];\
\
        \cf19 while \cf21 (\cf22 num \cf19 >= \cf23 base\cf21 ) \{\
            \cf23 sb\cf21 .\cf20 append\cf21 (\cf23 map\cf21 .\cf20 get\cf21 (\cf23 base\cf21 ));\
            \cf22 num \cf19 -= \cf23 base\cf21 ;\
        \}\
    \}\
\
    \cf19 return \cf23 sb\cf21 .\cf20 toString\cf21 ();\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs24 \cf21 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \
********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
13.\'a0Roman to Integer
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f3\fs24 \cf21 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs30 \cf19 public static int \cf20 romanToInt\cf21 (\cf20 String \cf22 s\cf21 ) \{\
    \cf19 int \cf23 res \cf19 = \cf23 0\cf21 ;\
    \cf19 int\cf21 [] \cf23 n \cf19 = \cf21 \{\cf23 1\cf21 , \cf23 4\cf21 , \cf23 5\cf21 , \cf23 9\cf21 , \cf23 10\cf21 , \cf23 40\cf21 , \cf23 50\cf21 , \cf23 90\cf21 , \cf23 100\cf21 , \cf23 400\cf21 , \cf23 500\cf21 , \cf23 900\cf21 , \cf23 1000\cf21 \};\
    \cf20 String\cf21 [] \cf23 sym \cf19 = \cf21 \{\cf33 "I"\cf21 , \cf33 "IV"\cf21 , \cf33 "V"\cf21 , \cf33 "IX"\cf21 , \cf33 "X"\cf21 , \cf33 "XL"\cf21 , \cf33 "L"\cf21 , \cf33 "XC"\cf21 , \cf33 "C"\cf21 , \cf33 "CD"\cf21 , \cf33 "D"\cf21 , \cf33 "CM"\cf21 , \cf33 "M"\cf21 \};\
    \cf24 // 1:I, 10:X, 100:C\
    // i+1 or i+3\
    \cf19 for\cf21 (\cf19 int \cf23 i\cf19 =\cf23 0\cf21 ; \cf23 i\cf19 <\cf22 s\cf21 .\cf20 length\cf21 (); \cf23 i\cf19 ++\cf21 ) \{\
        \cf19 int \cf23 k \cf19 = \cf23 i\cf21 ;  \cf24 // index for sym[] and n[]\
        \cf20 String \cf23 currentChar \cf19 = \cf20 Character\cf21 .\cf20 toString\cf21 (\cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i\cf21 ));\
        \cf19 for\cf21 (\cf19 int \cf23 j\cf19 =\cf23 0\cf21 ; \cf23 j\cf19 <\cf23 sym\cf21 .length; \cf23 j\cf19 ++\cf21 ) \{\
            \cf19 if\cf21 (\cf23 i\cf19 <\cf22 s\cf21 .\cf20 length\cf21 ()\cf19 -\cf23 1 \cf19 && \cf23 currentChar\cf21 .\cf20 equals\cf21 (\cf23 sym\cf21 [\cf23 j\cf21 ])) \{\
\
                \cf19 if\cf21 (\cf23 currentChar\cf21 .\cf20 equals\cf21 (\cf33 "I"\cf21 ) \cf19 || \cf23 currentChar\cf21 .\cf20 equals\cf21 (\cf33 "X"\cf21 ) \cf19 || \cf23 currentChar\cf21 .\cf20 equals\cf21 (\cf33 "C"\cf21 )) \{\
                    \cf20 String \cf23 nextChar \cf19 = \cf23 currentChar \cf19 + \cf20 Character\cf21 .\cf20 toString\cf21 (\cf22 s\cf21 .\cf20 charAt\cf21 (\cf23 i \cf19 + \cf23 1\cf21 ));\
                    \cf19 if \cf21 (\cf23 nextChar\cf21 .\cf20 equals\cf21 (\cf23 sym\cf21 [\cf23 j \cf19 + \cf23 1\cf21 ]))\{   \cf24 // digit 4\
                        \cf23 res \cf19 += \cf23 n\cf21 [\cf23 j \cf19 + \cf23 1\cf21 ];\
                        \cf23 i \cf19 += \cf23 1\cf21 ;\
                    \} \cf19 else if\cf21 (\cf23 nextChar\cf21 .\cf20 equals\cf21 (\cf23 sym\cf21 [\cf23 j\cf19 +\cf23 3\cf21 ])) \{  \cf24 // digit 9\
                        \cf23 res \cf19 += \cf23 n\cf21 [\cf23 j \cf19 + \cf23 3\cf21 ];\
                        \cf23 i \cf19 += \cf23 1\cf21 ;\
                    \} \cf19 else \cf21 \{\
                        \cf23 res \cf19 += \cf23 n\cf21 [\cf23 j\cf21 ];\
                    \}\
                \}  \cf19 else \cf21 \{\
                    \cf23 res \cf19 += \cf23 n\cf21 [\cf23 j\cf21 ];    \cf24 // others\
                \cf21 \}\
                \cf19 break\cf21 ;\
            \}\
\
            \cf19 if\cf21 (\cf23 i\cf19 ==\cf22 s\cf21 .\cf20 length\cf21 ()\cf19 -\cf23 1 \cf19 && \cf23 currentChar\cf21 .\cf20 equals\cf21 (\cf23 sym\cf21 [\cf23 j\cf21 ])) \{\
                \cf23 res \cf19 += \cf23 n\cf21 [\cf23 j\cf21 ];\
                \cf19 break\cf21 ;\
            \}\
        \}\
    \}\
\
    \cf19 return \cf23 res\cf21 ;\
\}\
\cf33 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf6 ************Sample************\cf33 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf19 public static int \cf20 romanToInt_Sample\cf21 (\cf20 String \cf22 s\cf21 ) \{\
    \cf20 Map\cf19 <\cf20 String\cf21 , \cf20 Integer\cf19 > \cf23 nums \cf19 = new \cf20 HashMap\cf19 <>\cf21 ();\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "M"\cf21 , \cf23 1000\cf21 );\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "CM"\cf21 , \cf23 900\cf21 );\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "D"\cf21 , \cf23 500\cf21 );\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "CD"\cf21 , \cf23 400\cf21 );\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "C"\cf21 , \cf23 100\cf21 );\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "XC"\cf21 , \cf23 90\cf21 );\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "L"\cf21 , \cf23 50\cf21 );\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "XL"\cf21 , \cf23 40\cf21 );\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "X"\cf21 , \cf23 10\cf21 );\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "IX"\cf21 , \cf23 9\cf21 );\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "V"\cf21 , \cf23 5\cf21 );\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "IV"\cf21 , \cf23 4\cf21 );\
    \cf23 nums\cf21 .\cf20 put\cf21 (\cf33 "I"\cf21 , \cf23 1\cf21 );\
    \cf19 int \cf23 res \cf19 = \cf23 0\cf21 ;\
    \cf19 for \cf21 (\cf19 int \cf23 i \cf19 = \cf23 0\cf21 ; \cf23 i \cf19 < \cf22 s\cf21 .\cf20 length\cf21 ();) \{\
        \cf20 System\cf21 .\cf23 out\cf21 .\cf20 println\cf21 (\cf23 i \cf19 + \cf33 "-" \cf19 + \cf22 s\cf21 .\cf20 substring\cf21 (\cf23 i\cf21 , \cf23 i \cf19 + \cf23 2\cf21 ));\
        \cf19 if \cf21 (\cf23 i \cf19 + \cf23 1 \cf19 < \cf22 s\cf21 .\cf20 length\cf21 () \cf19 && \cf23 nums\cf21 .\cf20 get\cf21 (\cf22 s\cf21 .\cf20 substring\cf21 (\cf23 i\cf21 , \cf23 i \cf19 + \cf23 2\cf21 )) \cf19 != \cf23 null\cf21 ) \{\
            \cf23 res \cf19 += \cf23 nums\cf21 .\cf20 get\cf21 (\cf22 s\cf21 .\cf20 substring\cf21 (\cf23 i\cf21 , \cf23 i \cf19 + \cf23 2\cf21 ));\
            \cf23 i \cf19 += \cf23 2\cf21 ;\
        \} \cf19 else \cf21 \{\
            \cf23 res \cf19 += \cf23 nums\cf21 .\cf20 get\cf21 (\cf22 s\cf21 .\cf20 substring\cf21 (\cf23 i\cf21 , \cf23 i \cf19 + \cf23 1\cf21 ));\
            \cf23 i \cf19 += \cf23 1\cf21 ;\
        \}\
    \}\
    \cf19 return \cf23 res\cf21 ;\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f6\fs24 \cf33 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \
********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
14.\'a0Longest Common Prefix
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
// only compare the from left to right\
********************************************************************************************************
\f6\fs24 \cf33 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf20 //sample
\f3\fs24 \cf21 \

\f6\fs28 \cf19 public static \cf20 String longestCommonPrefix\cf21 (\cf20 String\cf21 [] \cf22 strs\cf21 ) \{\
    \cf19 int \cf23 n \cf19 = \cf22 strs\cf21 .length;\
    \cf19 for \cf21 (\cf19 int \cf23 i \cf19 = \cf23 0\cf21 ; \cf23 i \cf19 < \cf22 strs\cf21 [\cf23 0\cf21 ].\cf20 length\cf21 (); \cf19 ++\cf23 i\cf21 ) \{\
        \cf19 for \cf21 (\cf19 int \cf23 j \cf19 = \cf23 1\cf21 ; \cf23 j \cf19 < \cf23 n\cf21 ; \cf19 ++\cf23 j\cf21 ) \{\
            \cf24 //System.out.println(strs[j].length() + "-" + i);\
            \cf20 System\cf21 .\cf23 out\cf21 .\cf20 println\cf21 (\cf22 strs\cf21 [\cf23 j\cf21 ].\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 + \cf33 "-" \cf19 + \cf22 strs\cf21 [\cf23 0\cf21 ].\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 + \cf33 "-" \cf19 + \cf23 j\cf21 );\
            \cf19 if \cf21 (\cf22 strs\cf21 [\cf23 j\cf21 ].\cf20 length\cf21 () \cf19 <= \cf23 i \cf19 || \cf22 strs\cf21 [\cf23 j\cf21 ].\cf20 charAt\cf21 (\cf23 i\cf21 ) \cf19 != \cf22 strs\cf21 [\cf23 0\cf21 ].\cf20 charAt\cf21 (\cf23 i\cf21 )) \{\
                \cf19 return \cf22 strs\cf21 [\cf23 0\cf21 ].\cf20 substring\cf21 (\cf23 0\cf21 , \cf23 i\cf21 );\
            \}\
        \}\
    \}\
    \cf19 return \cf22 strs\cf21 [\cf23 0\cf21 ];\
\}\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 \
********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
15.\'a03 Sum
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f6 \cf21 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs24 \cf19 public static 
\f9\i \cf20 List
\f6\i0 \cf19 <
\f9\i \cf20 List
\f6\i0 \cf19 <\cf20 Integer\cf19 >> \cf20 threeSum2\cf21 (\cf19 int\cf21 [] \cf22 nums\cf21 ) \{\
    
\f9\i \cf20 List
\f6\i0 \cf19 <
\f9\i \cf20 List
\f6\i0 \cf19 <\cf20 Integer\cf19 >> \cf23 triplet \cf19 = new \cf20 ArrayList\cf19 <>\cf21 ();\
\
    \cf20 Arrays\cf21 .
\f9\i \cf20 sort
\f6\i0 \cf21 (\cf22 nums\cf21 );\
    \cf20 System\cf21 .
\f9\i \cf23 out
\f6\i0 \cf21 .\cf20 println\cf21 (\cf20 Arrays\cf21 .
\f9\i \cf20 toString
\f6\i0 \cf21 (\cf22 nums\cf21 ));\
\
    \cf19 for\cf21 (\cf19 int \cf23 i\cf19 =\cf23 0\cf21 ; \cf23 i\cf19 <\cf22 nums\cf21 .length\cf19 -\cf23 2 \cf19 && \cf22 nums\cf21 [\cf23 i\cf21 ] \cf19 <= \cf23 0\cf21 ; \cf23 i\cf19 ++\cf21 ) \{\
        \cf19 if\cf21 (\cf23 i\cf19 >\cf23 0 \cf19 && \cf22 nums\cf21 [\cf23 i\cf21 ] \cf19 == \cf22 nums\cf21 [\cf23 i\cf19 -\cf23 1\cf21 ])\
            \cf19 continue\cf21 ;\
\
        \cf19 int \cf23 j\cf19 =\cf23 i\cf19 +\cf23 1\cf21 ;\
        \cf19 int \cf23 k\cf19 =\cf22 nums\cf21 .length\cf19 -\cf23 1\cf21 ;\
        \cf19 while\cf21 (\cf23 k \cf19 > \cf23 j\cf21 ) \{\
            \cf19 int \cf23 current \cf19 = \cf22 nums\cf21 [\cf23 i\cf21 ] \cf19 + \cf22 nums\cf21 [\cf23 j\cf21 ] \cf19 + \cf22 nums \cf21 [\cf23 k\cf21 ];\
            \cf19 if\cf21 (\cf23 current \cf19 == \cf23 0\cf21 ) \{\
                \cf23 triplet\cf21 .\cf20 add\cf21 (\cf20 Arrays\cf21 .
\f9\i \cf20 asList
\f6\i0 \cf21 (\cf22 nums\cf21 [\cf23 i\cf21 ], \cf22 nums\cf21 [\cf23 j\cf19 ++\cf21 ], \cf22 nums\cf21 [\cf23 k\cf19 --\cf21 ]));\
                \cf19 while\cf21 (\cf23 j\cf19 <\cf22 nums\cf21 .length \cf19 && \cf22 nums\cf21 [\cf23 j\cf21 ] \cf19 == \cf22 nums\cf21 [\cf23 j\cf19 -\cf23 1\cf21 ])\{\
                    \cf19 ++\cf23 j\cf21 ;\
                \}\
                \cf19 while\cf21 (\cf23 k\cf19 >\cf23 j \cf19 && \cf22 nums\cf21 [\cf23 k\cf21 ] \cf19 == \cf22 nums\cf21 [\cf23 k\cf19 +\cf23 1\cf21 ]) \{\
                    \cf19 --\cf23 k\cf21 ;\
                \}\
            \} \cf19 else if\cf21 (\cf23 current \cf19 < \cf23 0\cf21 ) \{\
                \cf23 j\cf19 ++\cf21 ;\
            \} \cf19 else \cf21 \{\
                \cf23 k\cf19 --\cf21 ;\
            \}\
\
        \}\
    \}\
\
    \cf19 return \cf23 triplet\cf21 ;\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf21 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
16.\'a03 Sum Closest
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f6\fs24 \cf21 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf19 public static int \cf20 threeSumClosest\cf21 (\cf19 int\cf21 [] \cf22 nums\cf21 , \cf19 int \cf22 target\cf21 ) \{\
    \cf19 int \cf23 distance \cf19 = \cf20 Integer\cf21 .
\f9\i \cf23 MAX_VALUE
\f6\i0 \cf21 ;\
    \cf20 Arrays\cf21 .
\f9\i \cf20 sort
\f6\i0 \cf21 (\cf22 nums\cf21 );\
    \cf20 System\cf21 .
\f9\i \cf23 out
\f6\i0 \cf21 .\cf20 println\cf21 (\cf20 Arrays\cf21 .
\f9\i \cf20 toString
\f6\i0 \cf21 (\cf22 nums\cf21 ));\
\
    \cf19 for\cf21 (\cf19 int \cf23 i\cf19 =\cf23 0\cf21 ; \cf23 i\cf19 <\cf22 nums\cf21 .length\cf19 -\cf23 2\cf21 ; \cf23 i\cf19 ++\cf21 ) \{\
        \cf19 int \cf23 j \cf19 = \cf23 i\cf19 +\cf23 1\cf21 ;\
        \cf19 int \cf23 k \cf19 = \cf22 nums\cf21 .length \cf19 - \cf23 1\cf21 ;\
        \cf19 while \cf21 (\cf23 j \cf19 < \cf23 k\cf21 ) \{\
            \cf19 int \cf23 current \cf19 = \cf22 nums\cf21 [\cf23 i\cf21 ] \cf19 + \cf22 nums\cf21 [\cf23 j\cf21 ] \cf19 + \cf22 nums\cf21 [\cf23 k\cf21 ];\
\
            \cf19 if\cf21 (\cf23 current \cf19 == \cf22 target\cf21 ) \{\
                \cf19 return \cf23 current\cf21 ;\
            \}\
\
            \cf19 if\cf21 (\cf20 Math\cf21 .
\f9\i \cf20 abs
\f6\i0 \cf21 (\cf22 target \cf19 - \cf23 distance\cf21 ) \cf19 > \cf20 Math\cf21 .
\f9\i \cf20 abs
\f6\i0 \cf21 (\cf22 target \cf19 - \cf23 current\cf21 )) \{\
                \cf23 distance \cf19 = \cf23 current\cf21 ;\
            \}\
\
            \cf19 if\cf21 (\cf23 current \cf19 > \cf22 target\cf21 ) \{\
                \cf23 k\cf19 --\cf21 ;\
            \} \cf19 else \cf21 \{\
                \cf23 j\cf19 ++\cf21 ;\
            \}\
        \}\
    \}\
\
    \cf19 return \cf23 distance\cf21 ;\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf21 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
16.\'a0Letter Combinations of a Phone Number
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f0\b\fs72 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f6\b0\fs24 \cf21 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf19 public static 
\f9\i \cf20 List
\f6\i0 \cf19 <\cf20 String\cf19 > \cf20 letterCombinations2\cf21 (\cf20 String \cf21 digits) \{\
    
\f9\i \cf20 List
\f6\i0 \cf19 <\cf20 String\cf19 > \cf23 ans \cf19 = new \cf20 ArrayList\cf19 <\cf20 String\cf19 >\cf21 ();\
    
\f9\i \cf20 Map
\f6\i0 \cf19 <\cf20 Integer\cf21 , \cf20 String\cf19 > \cf23 phoneNum \cf19 = new \cf20 HashMap\cf19 <\cf20 Integer\cf21 , \cf20 String \cf19 >\cf21 ();\
    \cf23 phoneNum\cf21 .\cf20 put\cf21 (\cf23 2\cf21 , \cf33 "abc"\cf21 );\
    \cf23 phoneNum\cf21 .\cf20 put\cf21 (\cf23 3\cf21 , \cf33 "def"\cf21 );\
    \cf23 phoneNum\cf21 .\cf20 put\cf21 (\cf23 4\cf21 , \cf33 "ghi"\cf21 );\
    \cf23 phoneNum\cf21 .\cf20 put\cf21 (\cf23 5\cf21 , \cf33 "jkl"\cf21 );\
    \cf23 phoneNum\cf21 .\cf20 put\cf21 (\cf23 6\cf21 , \cf33 "mno"\cf21 );\
    \cf23 phoneNum\cf21 .\cf20 put\cf21 (\cf23 7\cf21 , \cf33 "pqrs"\cf21 );\
    \cf23 phoneNum\cf21 .\cf20 put\cf21 (\cf23 8\cf21 , \cf33 "tuv"\cf21 );\
    \cf23 phoneNum\cf21 .\cf20 put\cf21 (\cf23 9\cf21 , \cf33 "wxyz"\cf21 );\
\
\
    \cf24 // Traversing through Map using for-each loop\
    \cf19 for \cf21 (
\f9\i \cf20 Map
\f6\i0 \cf21 .
\f9\i \cf20 Entry
\f6\i0 \cf19 <\cf20 Integer\cf21 , \cf20 String\cf19 > \cf23 me \cf19 : \cf23 phoneNum\cf21 .\cf20 entrySet\cf21 ()) \{\
        \cf24 // Printing keys\
        //System.out.println(me.getKey() + ":" + me.getValue());\
        \cf19 if\cf21 (\cf23 me\cf21 .\cf20 getKey\cf21 () \cf19 == \cf23 7 \cf19 || \cf23 me\cf21 .\cf20 getKey\cf21 () \cf19 == \cf23 9\cf21 )\
            \cf20 System\cf21 .
\f9\i \cf23 out
\f6\i0 \cf21 .\cf20 println\cf21 (\cf23 me\cf21 .\cf20 getValue\cf21 () \cf19 + \cf33 ":" \cf19 + \cf23 me\cf21 .\cf20 getValue\cf21 ().\cf20 length\cf21 ());\
    \}\
\
    \cf19 int \cf23 digitsToInt \cf19 = \cf20 Integer\cf21 .
\f9\i \cf20 parseInt
\f6\i0 \cf21 (\cf22 digits\cf21 );\
    \cf20 String\cf21 [] \cf23 storeAlpha \cf19 = new \cf20 String\cf21 [
\f9\i \cf20 countDigit
\f6\i0 \cf21 (\cf23 digitsToInt\cf21 )];\
    \cf19 int \cf23 index \cf19 = \cf23 0\cf21 ;\
    \cf19 while\cf21 (\cf23 digitsToInt \cf19 > \cf23 0\cf21 ) \{\
        \cf19 int \cf23 t \cf19 = \cf23 digitsToInt \cf19 % \cf23 10\cf21 ;\
        \cf23 digitsToInt \cf19 = \cf23 digitsToInt \cf19 / \cf23 10\cf21 ;\
        \cf24 //System.out.println(t);\
        \cf19 if\cf21 (\cf23 t \cf19 >= \cf23 2\cf21 ) \{\
            \cf23 storeAlpha\cf21 [\cf23 index\cf21 ] \cf19 = \cf23 phoneNum\cf21 .\cf20 get\cf21 (\cf23 t\cf21 );\
            \cf23 index\cf19 ++\cf21 ;\
        \}\
    \}\
\
    \cf20 Arrays\cf21 .
\f9\i \cf20 sort
\f6\i0 \cf21 (\cf23 storeAlpha\cf21 );\
    \cf20 System\cf21 .
\f9\i \cf23 out
\f6\i0 \cf21 .\cf20 println\cf21 (\cf20 Arrays\cf21 .
\f9\i \cf20 toString
\f6\i0 \cf21 (\cf23 storeAlpha\cf21 ));\
    \cf20 System\cf21 .
\f9\i \cf23 out
\f6\i0 \cf21 .\cf20 println\cf21 (\cf23 storeAlpha\cf21 [\cf23 0\cf21 ].\cf20 charAt\cf21 (\cf23 0\cf21 ));\
    \cf20 String \cf23 a \cf19 = \cf20 String\cf21 .
\f9\i \cf20 valueOf
\f6\i0 \cf21 (\cf23 storeAlpha\cf21 [\cf23 0\cf21 ].\cf20 charAt\cf21 (\cf23 0\cf21 )) \cf19 + \cf20 String\cf21 .
\f9\i \cf20 valueOf
\f6\i0 \cf21 (\cf23 storeAlpha\cf21 [\cf23 1\cf21 ].\cf20 charAt\cf21 (\cf23 0\cf21 )) \cf19 + \cf20 String\cf21 .
\f9\i \cf20 valueOf
\f6\i0 \cf21 (\cf23 storeAlpha\cf21 [\cf23 2\cf21 ].\cf20 charAt\cf21 (\cf23 0\cf21 ));\
    \cf23 ans\cf21 .\cf20 add\cf21 (\cf23 a\cf21 );\
    \cf19 int \cf23 len \cf19 = \cf23 storeAlpha\cf21 .length \cf19 - \cf23 2\cf21 ;\
    \cf19 for\cf21 (\cf19 int \cf23 i\cf19 =\cf23 0\cf21 ; \cf23 i\cf19 <\cf23 storeAlpha\cf21 [\cf23 0\cf21 ].\cf20 length\cf21 (); \cf23 i\cf19 ++\cf21 ) \{\
        \cf20 String \cf23 a \cf19 = \cf20 String\cf21 .
\f9\i \cf20 valueOf
\f6\i0 \cf21 (\cf23 storeAlpha\cf21 [\cf23 i\cf21 ].\cf20 charAt\cf21 (\cf23 i\cf21 ));\
        \cf19 for\cf21 (\cf19 int \cf23 j\cf19 =\cf23 0\cf21 ; \cf23 j\cf19 <\cf23 storeAlpha\cf21 [\cf23 i\cf21 ].\cf20 length\cf21 (); \cf23 j\cf19 ++\cf21 ) \{\
            \cf19 for\cf21 (\cf19 int \cf21 )\
        \}\
    \}\
    \cf19 return \cf23 ans\cf21 ;\
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f3\fs32 \cf6 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 ************************************
\fs32 \cb10 sample answer
\fs28 \cb1 ************************************ 
\f9\i\fs24 \cf20 \
List
\f6\i0 \cf19 <\cf20 String\cf19 > \cf23 ans \cf19 = new \cf20 ArrayList\cf19 <\cf20 String\cf19 >\cf21 ();\
    
\f9\i \cf24 /*String[][] store = \{\{"a","b","c"\},\
            \{"d","e","f"\},\
            \{"g","h","i"\},\
            \{"j","k","l"\},\
            \{"m","n","o"\},\
            \{"p","q","r","s"\},\
            \{"t","u","v"\},\
            \{"w","x","y","z"\}\
    \};\
*/\
    
\f6\i0 \cf20 String\cf21 [] \cf23 store  \cf19 = \cf21 \{\cf33 "abc"\cf21 , \cf33 "def"\cf21 , \cf33 "ghi"\cf21 , \cf33 "jkl"\cf21 , \cf33 "mno"\cf21 , \cf33 "pqrs"\cf21 , \cf33 "tuv"\cf21 , \cf33 "wxyz"\cf21 \};\
    \cf24 // i=5 & i=7 are special case with 4 letters\
    \cf19 int \cf23 digitsToInt \cf19 = \cf20 Integer\cf21 .
\f9\i \cf20 parseInt
\f6\i0 \cf21 (\cf22 digits\cf21 );\
    \cf19 while\cf21 (\cf23 digitsToInt \cf19 > \cf23 0\cf21 ) \{\
        \cf19 int \cf23 t \cf19 = \cf23 digitsToInt \cf19 % \cf23 10\cf21 ;\
        \cf23 digitsToInt \cf19 = \cf23 digitsToInt \cf19 / \cf23 10\cf21 ;\
        \cf20 System\cf21 .
\f9\i \cf23 out
\f6\i0 \cf21 .\cf20 println\cf21 (\cf23 t\cf21 );\
        \cf19 if\cf21 (\cf23 t \cf19 >= \cf23 2\cf21 )\
            \cf23 ans\cf21 .\cf20 add\cf21 (\cf23 store\cf21 [\cf23 t\cf19 -\cf23 2\cf21 ]);\
    \}\
    \cf20 Collections\cf21 .
\f9\i \cf20 sort
\f6\i0 \cf21 (\cf23 ans\cf21 );\
    \cf19 return \cf23 ans\cf21 ;\cf23 \
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf21 ::::\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf19 for\cf21 (\cf19 int \cf23 i\cf19 =\cf23 1\cf21 ; \cf23 i\cf19 <\cf23 storeAlpha\cf21 .length; \cf23 i\cf19 ++\cf21 ) \{\
    \cf19 for\cf21 (\cf19 int \cf23 j\cf19 =\cf23 0\cf21 ; \cf23 j\cf19 <\cf23 storeAlpha\cf21 [\cf23 i\cf21 ].\cf20 length\cf21 (); \cf23 j\cf19 ++\cf21 ) \{\
\
        \cf23 ans\cf21 .\cf20 add\cf21 (\cf23 current \cf19 + \cf23 storeAlpha\cf21 [\cf23 i\cf21 ].\cf20 charAt\cf21 (\cf23 j\cf21 ));\
        \cf20 System\cf21 .
\f9\i \cf23 out
\f6\i0 \cf21 .\cf20 println\cf21 (\cf23 storeAlpha\cf21 [\cf23 i\cf21 ].\cf20 charAt\cf21 (\cf23 j\cf21 ));\
    \}\
\}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f3\fs32 \cf6 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 ************************************
\fs32 \cb10 sample answer Python
\fs28 \cb1 ************************************ 
\f6\fs24 \cf21 \
dmap = \{'2': 'abc',\
        '3': 'def',\
        '4': 'ghi',\
        '5': 'jkl',\
        '6': 'mno',\
        '7': 'pqrs',\
        '8': 'tuv',\
        '9': 'wxyz',\
        '0': ' ',\
        None: None\}\
\
class Solution(object):\
    def letterCombinations(self, digits):\
        # DFS\
        result = []\
        ls = len(digits)\
        if ls == 0:\
            return result\
        current = digits[0]\
        posfix = self.letterCombinations(digits[1:])\
        for t in dmap[current]:\
            if len(posfix) > 0:\
                for p in posfix:\
                    temp = t + p\
                    result.append(temp)\
            else:\
                result.append(t)\
        return result\
\

\f1\fs28 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
18.\'a0FourSome
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f0\b\fs72 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f6\b0\fs24 \cf21 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf19 public static 
\f9\i \cf20 List
\f6\i0 \cf19 <
\f9\i \cf20 List
\f6\i0 \cf19 <\cf20 Integer\cf19 >> \cf20 fourSum\cf21 (\cf19 int\cf21 [] \cf22 nums\cf21 , \cf19 int \cf22 target\cf21 ) \{\
        
\f9\i \cf20 List
\f6\i0 \cf19 <
\f9\i \cf20 List
\f6\i0 \cf19 <\cf20 Integer\cf19 >> \cf23 rtnList \cf19 = new \cf20 ArrayList\cf19 <>\cf21 ();\
\
        \cf20 Arrays\cf21 .
\f9\i \cf20 sort
\f6\i0 \cf21 (\cf22 nums\cf21 );\
        \cf20 System\cf21 .
\f9\i \cf23 out
\f6\i0 \cf21 .\cf20 println\cf21 (\cf20 Arrays\cf21 .
\f9\i \cf20 toString
\f6\i0 \cf21 (\cf22 nums\cf21 ));\
        \
        \cf19 for\cf21 (\cf19 int \cf23 leftest\cf19 =\cf23 0\cf21 ; \cf23 leftest\cf19 <\cf22 nums\cf21 .length; \cf23 leftest\cf19 ++\cf21 ) \{\
            \cf19 for\cf21 (\cf19 int \cf23 rightest \cf19 = \cf22 nums\cf21 .length\cf19 -\cf23 1\cf21 ; \cf23 rightest\cf19 >=\cf23 0 \cf19 && \cf23 rightest \cf19 != \cf23 leftest\cf21 ; \cf23 rightest\cf19 --\cf21 ) \{\
                \cf19 int \cf23 secLeft \cf19 = \cf23 leftest\cf19 +\cf23 1\cf21 ;\
                \cf19 int \cf23 secRight \cf19 = \cf23 rightest\cf19 -\cf23 1\cf21 ;\
                \cf19 while \cf21 (\cf23 secLeft \cf19 < \cf23 secRight\cf21 ) \{\
                    \cf19 int \cf23 sum \cf19 = \cf22 nums\cf21 [\cf23 leftest\cf21 ] \cf19 + \cf22 nums\cf21 [\cf23 secLeft\cf21 ] \cf19 + \cf22 nums\cf21 [\cf23 secRight\cf21 ] \cf19 + \cf22 nums\cf21 [\cf23 rightest\cf21 ];\
\cf24 //                    System.out.println(sum + " : " + target);\
//                    System.out.println(secLeft + ":" + secRight);\
                    \cf19 if\cf21 (\cf23 sum \cf19 == \cf22 target\cf21 ) \{\
\cf24 //                        System.out.println("Here");\
                        
\f9\i \cf20 List
\f6\i0 \cf19 <\cf20 Integer\cf19 > \cf23 innerList \cf19 = new \cf20 ArrayList\cf19 <\cf20 Integer\cf19 >\cf21 ();\
                        \cf23 innerList\cf21 .\cf20 add\cf21 (\cf22 nums\cf21 [\cf23 leftest\cf21 ]);\
                        \cf23 innerList\cf21 .\cf20 add\cf21 (\cf22 nums\cf21 [\cf23 secLeft\cf21 ]);\
                        \cf23 innerList\cf21 .\cf20 add\cf21 (\cf22 nums\cf21 [\cf23 secRight\cf21 ]);\
                        \cf23 innerList\cf21 .\cf20 add\cf21 (\cf22 nums\cf21 [\cf23 rightest\cf21 ]);\
\
\cf24 //                        System.out.println(innerList);\
                        // checkDistinct not work\
//                        System.out.println(checkDistinct(rtnList, innerList));\
                        \cf19 if\cf21 (\cf23 rtnList\cf21 .\cf20 isEmpty\cf21 () \cf19 || 
\f9\i \cf20 checkDistinct
\f6\i0 \cf21 (\cf23 rtnList\cf21 , \cf23 innerList\cf21 )) \{\
\cf24 //                            System.out.println("Here: " + innerList);\
//                            System.out.println(nums[secLeft] + " : " + nums[secRight]);\
                            \cf23 rtnList\cf21 .\cf20 add\cf21 (\cf23 innerList\cf21 );\
                        \}\
\cf24 //                        System.out.println("Here: " + innerList);\
                        \cf23 secLeft\cf19 ++\cf21 ;\
                    \} \cf19 else if\cf21 (\cf23 sum \cf19 < \cf22 target\cf21 ) \{\
                        \cf23 secLeft\cf19 ++\cf21 ;\
                    \} \cf19 else \cf21 \{\
                        \cf23 secRight\cf19 --\cf21 ;\
                    \}\
\cf24 //                    System.out.println(rtnList);\
//                    System.out.println(secLeft + ":" + secRight);\
                    \cf19 if\cf21 (\cf22 nums\cf21 [\cf23 secLeft\cf21 ] \cf19 > \cf22 nums\cf21 [\cf23 secRight\cf21 ] \cf19 || \cf23 secLeft \cf19 == \cf23 secRight\cf21 )\
                        \cf19 break\cf21 ;\
                \}\
\
\cf24 //                System.out.println("OUT OF LOOP");\
            \cf21 \}\
        \}\
        \cf19 return \cf23 rtnList\cf21 ;\
    \}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \
********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
23.\'a0Merge Two Sorted Lists
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f6\fs24 \cf21 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf24 //         int min = Integer.MAX_VALUE;\
//         for(int i=0; i<lists.length; i++) \{\
//             int index = i;\
//             int min = Integer.MAX_VALUE;\
//             while(index < lists.length) \{\
//                 if(min > lists[index].val)\
//                     min = lists[index].val;\
//\
//                 index++;\
//             \}\
//\
//             System.out.println("Min = " + min);\
//             ListNode minValue = new ListNode(min);\
////             if(res == null) res = minValue;\
//             res.next = minValue;\
//         \}\
//\
//         ListNode copyRes = res;\
//         while(copyRes != null) \{\
//             System.out.println(copyRes.val);\
//             copyRes = copyRes.next;\
//         \}\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf21 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
41.\'a0First Missing Positive
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f6\fs24 \cf24 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf21 \
\cf24 // Time Limit Exceeded\
\cf19 public static int \cf20 firstMissingPositive\cf21 (\cf19 int\cf21 [] \cf22 nums\cf21 ) \{\
    \cf20 Arrays\cf21 .
\f9\i \cf20 sort
\f6\i0 \cf21 (\cf22 nums\cf21 );\
    
\f9\i \cf20 List
\f6\i0 \cf19 <\cf20 Integer\cf19 > \cf23 sortPosNum \cf19 = new \cf20 ArrayList\cf19 <>\cf21 ();\
\
    \cf19 for\cf21 (\cf19 int \cf23 n \cf19 : \cf22 nums\cf21 ) \{\
        \cf19 if\cf21 (\cf23 n \cf19 > \cf23 0 \cf19 && !\cf23 sortPosNum\cf21 .\cf20 contains\cf21 (\cf23 n\cf21 ))\
            \cf23 sortPosNum\cf21 .\cf20 add\cf21 (\cf23 n\cf21 );\
    \}\
\
    \cf19 if\cf21 (\cf23 sortPosNum\cf21 .\cf20 isEmpty\cf21 () \cf19 || \cf23 sortPosNum\cf21 .\cf20 get\cf21 (\cf23 0\cf21 ) \cf19 != \cf23 1\cf21 )\
        \cf19 return \cf23 1\cf21 ;\
\
    \cf19 int \cf23 size \cf19 = \cf23 sortPosNum\cf21 .\cf20 size\cf21 ();\
    \cf19 for\cf21 (\cf19 int \cf23 i\cf19 =\cf23 1\cf21 ; \cf23 i\cf19 <\cf23 size\cf21 ; \cf23 i\cf19 ++\cf21 ) \{\
        \cf19 if\cf21 (\cf23 sortPosNum\cf21 .\cf20 get\cf21 (\cf23 i\cf21 ) \cf19 - \cf23 sortPosNum\cf21 .\cf20 get\cf21 (\cf23 i\cf19 -\cf23 1\cf21 ) \cf19 != \cf23 1\cf21 )\
            \cf19 return \cf23 sortPosNum\cf21 .\cf20 get\cf21 (\cf23 i\cf19 -\cf23 1\cf21 ) \cf19 + \cf23 1\cf21 ;\
    \}\
\
    \cf19 return \cf23 sortPosNum\cf21 .\cf20 get\cf21 (\cf23 size\cf19 -\cf23 1\cf21 ) \cf19 + \cf23 1\cf21 ;\
\}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf34 \cb21 ***************************************\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf21 \cb1 \
\
\pard\pardeftab720\partightenfactor0

\fs26 \cf35 \expnd0\expndtw0\kerning0
public\cf0  \cf35 int\cf0  \cf36 firstMissingPositive\cf37 (\cf35 int\cf37 []\cf0  nums\cf37 )\cf0  \cf37 \{\cf0 \
        \cf36 Arrays\cf37 .\cf36 sort\cf37 (\cf0 nums\cf37 );\cf0 \
        \cf35 int\cf0  len \cf38 \cb39 =\cf0 \cb1  nums\cf37 .\cf0 length\cf37 ;\cf0 \
        \cf35 int\cf0  prev \cf38 \cb39 =\cf0 \cb1  \cf38 \cb39 -\cf40 \cb1 1\cf37 ;\cf0 \
        \cf35 int\cf0  count \cf38 \cb39 =\cf0 \cb1  \cf40 0\cf37 ;\cf0  \cf41 // count <= elements\cf0 \
\
        \cf35 for\cf0  \cf37 (\cf35 int\cf0  num \cf38 \cb39 :\cf0 \cb1  nums\cf37 )\cf0  \cf37 \{\cf0 \
            \cf35 if\cf0  \cf37 (\cf0 num \cf38 \cb39 <=\cf0 \cb1  \cf40 0\cf37 )\cf0  \cf37 \{\cf0 \
                count\cf38 \cb39 ++\cf37 \cb1 ;\cf0 \
            \cf37 \}\cf0  \cf35 else\cf0 \
                \cf35 break\cf37 ;\cf0 \
        \cf37 \}\cf0 \
\
        \cf35 if\cf37 (\cf0 count \cf38 \cb39 <\cf0 \cb1  len \cf38 \cb39 &&\cf0 \cb1  nums\cf37 [\cf0 count\cf37 ]\cf0  \cf38 \cb39 !=\cf0 \cb1  \cf40 1\cf37 )\cf0 \
            \cf35 return\cf0  \cf40 1\cf37 ;\cf0 \
\
        \cf35 for\cf37 (\cf35 int\cf0  i\cf38 \cb39 =\cf0 \cb1 count\cf37 ;\cf0  i\cf38 \cb39 <\cf0 \cb1 len\cf37 ;\cf0  i\cf38 \cb39 ++\cf37 \cb1 )\cf0  \cf37 \{\cf0 \
            prev \cf38 \cb39 =\cf0 \cb1  nums\cf37 [\cf0 i\cf37 ];\cf0 \
            \cf35 if\cf37 (\cf0 i\cf38 \cb39 <\cf0 \cb1 len\cf38 \cb39 -\cf40 \cb1 1\cf0  \cf38 \cb39 &&\cf0 \cb1  nums\cf37 [\cf0 i\cf38 \cb39 +\cf40 \cb1 1\cf37 ]\cf38 \cb39 -\cf0 \cb1 prev \cf38 \cb39 >\cf0 \cb1  \cf40 1\cf37 )\cf0 \
                \cf35 return\cf0  prev \cf38 \cb39 +\cf0 \cb1  \cf40 1\cf37 ;\cf0 \
\
        \cf37 \}\cf0 \
\
        \cf35 return\cf0  \cf37 (\cf0 prev \cf38 \cb39 ==\cf0 \cb1  \cf38 \cb39 -\cf40 \cb1 1\cf37 )\cf0  \cf38 \cb39 ?\cf0 \cb1  \cf40 1\cf0  \cf38 \cb39 :\cf0 \cb1  nums\cf37 [\cf0 len\cf38 \cb39 -\cf40 \cb1 1\cf37 ]\cf0  \cf38 \cb39 +\cf0 \cb1  \cf40 1\cf37 ;\cf0 \
    \cf37 \}
\f1\fs28 \cf0 \kerning1\expnd0\expndtw0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
42.\'a0Trapping Rain Water
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0

\f6\b0\fs26 \cf26 public\cf0  \cf42 int\cf0  \cf43 trap\cf0 (\cf42 int\cf0 [] \cf44 height\cf0 ) \{\cb1 \
\cb3         \cf45 if\cf0 (height == \cf26 null\cf0  || \cf44 height\cf0 .\cf44 length\cf0  <= \cf29 1\cf0 ) \cf45 return\cf0  \cf29 0\cf0 ;\cb1 \
\
\cb3         \cf42 int\cf0  \cf44 water\cf0  = \cf29 0\cf0 ;\cb1 \
\cb3         \cf42 int\cf0  \cf44 i\cf0  = \cf29 0\cf0 ;\cb1 \
\cb3         \cf45 for\cf0 (; i<\cf44 height\cf0 .\cf44 length\cf0 ; i++) \{\cb1 \
\cb3             \cf45 if\cf0 (height[i] == \cf29 0\cf0 ) \cf45 continue\cf0 ;\cb1 \
\
\cb3             \cf42 int\cf0  \cf44 nextI\cf0  = \cf43 FindNextMax\cf0 (i, height);\cb1 \
\cb3             \cf45 if\cf0 (nextI == -\cf29 1\cf0 ) \cf45 continue\cf0 ;\cb1 \
\cb3             \cb1 \
\cb3             \cf42 int\cf0  \cf44 min\cf0  = \cf44 Math\cf0 .\cf43 min\cf0 (height[i], height[nextI]);\cb1 \
\cb3             \cf45 for\cf0 (\cf42 int\cf0  \cf44 j\cf0 =i; j<=nextI; j++) \{\cb1 \
\cb3                 \cf45 if\cf0 (j == nextI && water != \cf29 0\cf0 )\cb1 \
\cb3                     \cf45 break\cf0 ;\cb1 \
\cb3                 water += \cf44 Math\cf0 .\cf43 abs\cf0 (min - height[j]);\cb1 \
\cb3             \}\cb1 \
\cb3             \cb1 \
\cb3             i = nextI - \cf29 1\cf0 ;\cb1 \
\cb3         \}\cb1 \
\
\cb3         \cf45 return\cf0  water;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 private\cf0  \cf26 static\cf0  \cf42 int\cf0  \cf43 FindNextMax\cf0 (\cf42 int\cf0  \cf44 i\cf0 , \cf42 int\cf0 [] \cf44 height\cf0 ) \{\cb1 \
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 j\cf0 =i+\cf29 1\cf0 ; j<\cf44 height\cf0 .\cf44 length\cf0 ; j++) \{\cb1 \
\cb3             \cf45 if\cf0 (height[i] <= height[j])\cb1 \
\cb3                 \cf45 return\cf0  j;\cb1 \
\cb3         \}\cb1 \
\cb3         \cf45 return\cf0  -\cf29 1\cf0 ;\cb1 \
\cb3     \}\cb1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \kerning1\expnd0\expndtw0 ****************************************************************************
\f6\fs26 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720\partightenfactor0
\cf26 \cb3 public\cf0  \cf26 static\cf0  \cf42 int\cf0  \cf43 trap\cf0 (\cf42 int\cf0 [] \cf44 height\cf0 ) \{\cb1 \
\cb3         \cf45 if\cf0 (height == \cf26 null\cf0  || \cf44 height\cf0 .\cf44 length\cf0  <= \cf29 1\cf0 ) \cf45 return\cf0  \cf29 0\cf0 ;\cb1 \
\
\cb3         \cf42 int\cf0  \cf44 water\cf0  = \cf29 0\cf0 ;\cb1 \
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 i\cf0 =\cf29 1\cf0 ; i<\cf44 height\cf0 .\cf44 length\cf0 ;) \{\cb1 \
\cb3             \cf28 // Find Max on the Left\cf0 \cb1 \
\cb3             \cf42 int\cf0  \cf44 leftMax\cf0  = \cf43 FindLeftMax\cf0 (i, i-\cf29 1\cf0 , height);\cb1 \
\cb3             \cf45 if\cf0 (leftMax == -\cf29 1\cf0 ) \{\cb1 \
\cb3                 i++;\cb1 \
\cb3                 \cf45 continue\cf0 ;\cb1 \
\cb3             \}\cb1 \
\
\cb3             \cf42 int\cf0  \cf44 rightIndex\cf0  = i + \cf29 1\cf0 ;\cb1 \
\cb3             \cf42 int\cf0  \cf44 rightMax\cf0  = \cf43 FindRightMax\cf0 (i, rightIndex, height);\cb1 \
\cb3             \cf28 // Find Max on the Right\cf0 \cb1 \
\cb3             \cf45 while\cf0 (rightMax == -\cf29 1\cf0 ) \{\cb1 \
\cb3                 \cf45 if\cf0 (rightIndex == \cf44 height\cf0 .\cf44 length\cf0  - \cf29 1\cf0 ) \{\cb1 \
\cb3                     leftMax++;\cb1 \
\cb3                     i++;\cb1 \
\cb3                     rightIndex = i + \cf29 1\cf0 ;\cb1 \
\cb3                 \}\cb1 \
\cb3                 rightIndex++;\cb1 \
\cb3                 rightMax = \cf43 FindRightMax\cf0 (i, rightIndex, height);\cb1 \
\cb3             \}\cb1 \
\
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "********* i = "\cf0  + i + \cf46 " *********"\cf0 );\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "Left Max = "\cf0  + height[leftMax]);\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "Right Max = "\cf0  + height[rightMax]);\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "************************************"\cf0 );\cb1 \
\
\cb3             i = rightIndex + \cf29 1\cf0 ;\cb1 \
\cb3         \}\cb1 \
\
\cb3         \cf45 return\cf0  water;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 private\cf0  \cf26 static\cf0  \cf42 int\cf0  \cf43 FindRightMax\cf0 (\cf42 int\cf0  \cf44 i\cf0 , \cf42 int\cf0  \cf44 rightIndex\cf0 , \cf42 int\cf0 [] \cf44 height\cf0 ) \{\cb1 \
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 j\cf0 =rightIndex; j<\cf44 height\cf0 .\cf44 length\cf0 ; j++) \{\cb1 \
\cb3             \cf45 if\cf0 (height[j] > height[i])\cb1 \
\cb3                 \cf45 return\cf0  j;\cb1 \
\cb3         \}\cb1 \
\cb3         \cf45 return\cf0  -\cf29 1\cf0 ;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 private\cf0  \cf26 static\cf0  \cf42 int\cf0  \cf43 FindLeftMax\cf0 (\cf42 int\cf0  \cf44 i\cf0 , \cf42 int\cf0  \cf44 prevLeft\cf0 , \cf42 int\cf0 [] \cf44 height\cf0 ) \{\cb1 \
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 j\cf0 =i-\cf29 1\cf0 ; j>=prevLeft; j--) \{\cb1 \
\cb3             \cf45 if\cf0 (height[j] > height[i])\cb1 \
\cb3                 \cf45 return\cf0  j;\cb1 \
\cb3         \}\cb1 \
\cb3         \cf45 return\cf0  -\cf29 1\cf0 ;\cb1 \
\cb3     \}\cb1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\partightenfactor0
\cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \kerning1\expnd0\expndtw0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
43.\'a0Multiply Strings
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f6\fs26 \cf0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0
\cf26 \cb3 public\cf0  \cf26 static\cf0  \cf42 String\cf0  \cf43 multiply\cf0 (\cf42 String\cf0  \cf44 num1\cf0 , \cf42 String\cf0  \cf44 num2\cf0 ) \{\cb1 \
\cb3         \cf28 // len(num1) > len(num2)\cf0 \cb1 \
\cb3         \cf28 // if not swap\cf0 \cb1 \
\cb3         \cf45 if\cf0 (\cf44 num1\cf0 .\cf43 length\cf0 () < \cf44 num2\cf0 .\cf43 length\cf0 ()) \{\cb1 \
\cb3             \cf42 String\cf0  \cf44 tmp\cf0  = num1;\cb1 \
\cb3             num1 = num2;\cb1 \
\cb3             num2 = tmp;\cb1 \
\cb3         \}\cb1 \
\pard\pardeftab720\partightenfactor0
\cf28 \cb3 //        System.out.println(num1 + " : " + num2);\cf0 \cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf0 \cb3         \cf42 String\cf0 [] \cf44 partialProduct\cf0  = \cf45 new\cf0  \cf42 String\cf0 [\cf44 num2\cf0 .\cf43 length\cf0 ()];\cb1 \
\cb3         \cf42 int\cf0  \cf44 index\cf0  = \cf29 0\cf0 ;\cb1 \
\
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 i\cf0 =\cf44 num2\cf0 .\cf43 length\cf0 ()-\cf29 1\cf0 ; i>=\cf29 0\cf0 ; i--) \{\cb1 \
\cb3             \cf42 int\cf0  \cf44 bot\cf0  = \cf44 Integer\cf0 .\cf43 parseInt\cf0 (\cf44 String\cf0 .\cf43 valueOf\cf0 (\cf44 num2\cf0 .\cf43 charAt\cf0 (i)));\cb1 \
\cb3             \cf42 String\cf0  \cf44 product\cf0  = \cf46 ""\cf0 ;\cb1 \
\cb3             \cf42 int\cf0  \cf44 remain\cf0  = \cf29 0\cf0 ;\cb1 \
\cb3             \cf45 for\cf0 (\cf42 int\cf0  \cf44 j\cf0 =\cf44 num1\cf0 .\cf43 length\cf0 ()-\cf29 1\cf0 ; j>=\cf29 0\cf0 ; j--) \{\cb1 \
\cb3                 \cf42 int\cf0  \cf44 temp\cf0  = bot * \cf44 Integer\cf0 .\cf43 parseInt\cf0 (\cf44 String\cf0 .\cf43 valueOf\cf0 (\cf44 num1\cf0 .\cf43 charAt\cf0 (j))) + remain;\cb1 \
\cb3                 \cf45 if\cf0 (temp >= \cf29 10\cf0 ) \{\cb1 \
\cb3                     product = \cf44 String\cf0 .\cf43 valueOf\cf0 (temp % \cf29 10\cf0 ).\cf43 concat\cf0 (product);\cb1 \
\pard\pardeftab720\partightenfactor0
\cf28 \cb3 //                    product = product.concat(String.valueOf(temp % 10));\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3                     remain = temp / \cf29 10\cf0 ;\cb1 \
\cb3                 \} \cf45 else\cf0  \{\cb1 \
\cb3                     product = \cf44 String\cf0 .\cf43 valueOf\cf0 (temp).\cf43 concat\cf0 (product);\cb1 \
\pard\pardeftab720\partightenfactor0
\cf28 \cb3 //                    product = product.concat(String.valueOf(temp));\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3                     remain = \cf29 0\cf0 ;\cb1 \
\cb3                 \}\cb1 \
\cb3                 \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (temp + \cf46 " : "\cf0  + product);\cb1 \
\cb3             \}\cb1 \
\
\cb3             \cf45 if\cf0 (index != \cf29 0\cf0 )\cb1 \
\cb3                 partialProduct[index++] = \cf44 product\cf0 .\cf43 concat\cf0 (\cf43 getZero\cf0 (index-\cf29 1\cf0 ));\cb1 \
\cb3             \cf45 else\cf0 \cb1 \
\cb3                 partialProduct[index++] = product;\cb1 \
\
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "************************************"\cf0 );\cb1 \
\cb3         \}\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf28 \cb3 //        System.out.println(Arrays.toString(partialProduct));\cf0 \cb1 \
\cf28 \cb3 //        System.out.println("Max Length = " + getMaxLength(partialProduct));\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3         \cf42 int\cf0  \cf44 maxLen\cf0  = \cf43 getMaxLength\cf0 (partialProduct);\cb1 \
\cb3         \cf42 String\cf0 [] \cf44 fixed\cf0  = \cf43 fixProductDigit\cf0 (partialProduct, \cf43 getMaxLength\cf0 (partialProduct));\cb1 \
\
\cb3         \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "Fixed Array : "\cf0  + \cf44 Arrays\cf0 .\cf43 toString\cf0 (fixed));\cb1 \
\cb3         \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf43 getSum\cf0 (fixed, maxLen));\cb1 \
\cb3         \cf45 return\cf0  \cf46 ""\cf0 ;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 private\cf0  \cf26 static\cf0  \cf42 String\cf0  \cf43 getZero\cf0 (\cf42 int\cf0  \cf44 index\cf0 ) \{\cb1 \
\cb3         \cf42 String\cf0  \cf44 s\cf0  = \cf46 ""\cf0 ;\cb1 \
\cb3         \cf45 while\cf0 (index > \cf29 0\cf0 ) \{\cb1 \
\cb3             s = \cf44 s\cf0 .\cf43 concat\cf0 (\cf46 "0"\cf0 );\cb1 \
\cb3             index--;\cb1 \
\cb3         \}\cb1 \
\cb3         \cf45 return\cf0  s;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 private\cf0  \cf26 static\cf0  \cf42 int\cf0  \cf43 getMaxLength\cf0 (\cf42 String\cf0 [] \cf44 product\cf0 ) \{\cb1 \
\cb3         \cf42 int\cf0  \cf44 max\cf0  = \cf29 0\cf0 ;\cb1 \
\cb3         \cf45 for\cf0 (\cf42 String\cf0  \cf44 s\cf0  \cf45 :\cf0  product) \{\cb1 \
\cb3             \cf45 if\cf0 (\cf44 s\cf0 .\cf43 length\cf0 () > max)\cb1 \
\cb3                 max = \cf44 s\cf0 .\cf43 length\cf0 ();\cb1 \
\cb3         \}\cb1 \
\cb3         \cf45 return\cf0  max;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 private\cf0  \cf26 static\cf0  \cf42 String\cf0 [] \cf43 fixProductDigit\cf0 (\cf42 String\cf0 [] \cf44 product\cf0 , \cf42 int\cf0  \cf44 maxLen\cf0 ) \{\cb1 \
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 i\cf0 =\cf29 0\cf0 ; i<\cf44 product\cf0 .\cf44 length\cf0 ; i++) \{\cb1 \
\cb3             \cf42 int\cf0  \cf44 tmpLen\cf0  = product[i].\cf43 length\cf0 ();\cb1 \
\cb3             \cf45 if\cf0 (tmpLen != maxLen) \{\cb1 \
\cb3                 product[i] = \cf43 getZero\cf0 (maxLen - tmpLen).\cf43 concat\cf0 (product[i]);\cb1 \
\cb3                 \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (product[i]);\cb1 \
\cb3             \}\cb1 \
\cb3         \}\cb1 \
\cb3         \cf45 return\cf0  product;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 private\cf0  \cf26 static\cf0  \cf42 String\cf0  \cf43 getSum\cf0 (\cf42 String\cf0 [] \cf44 product\cf0 , \cf42 int\cf0  \cf44 maxLen\cf0 ) \{\cb1 \
\cb3         \cf42 String\cf0  \cf44 ans\cf0  = \cf46 ""\cf0 ;\cb1 \
\cb3         \cf42 int\cf0  \cf44 remain\cf0  = \cf29 0\cf0 ;\cb1 \
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 i\cf0 =maxLen-\cf29 1\cf0 ; i>=\cf29 0\cf0 ; i--) \{\cb1 \
\cb3             \cf42 String\cf0  \cf44 temp\cf0  = \cf46 ""\cf0 ;\cb1 \
\cb3             \cf42 int\cf0  \cf44 curSum\cf0  = remain;\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "Before loop curSum = "\cf0  + curSum);\cb1 \
\cb3             \cf45 for\cf0  (\cf42 int\cf0  \cf44 j\cf0  = \cf29 0\cf0 ; j<\cf44 product\cf0 .\cf44 length\cf0 ; j++) \{\cb1 \
\cb3                 curSum += \cf44 Integer\cf0 .\cf43 parseInt\cf0 (\cf44 String\cf0 .\cf43 valueOf\cf0 (product[j].\cf43 charAt\cf0 (i)));\cb1 \
\cb3             \}\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "curSum = "\cf0  + curSum);\cb1 \
\cb3             \cf45 if\cf0 (curSum >= \cf29 10\cf0  && i!=\cf29 0\cf0 ) \{\cb1 \
\cb3                 temp = \cf44 String\cf0 .\cf43 valueOf\cf0 (curSum % \cf29 10\cf0 ).\cf43 concat\cf0 (temp);\cb1 \
\cb3                 remain = curSum / \cf29 10\cf0 ;\cb1 \
\cb3             \} \cf45 else\cf0  \{\cb1 \
\cb3                 temp = \cf44 String\cf0 .\cf43 valueOf\cf0 (curSum).\cf43 concat\cf0 (temp);\cb1 \
\cb3                 remain = \cf29 0\cf0 ;\cb1 \
\cb3             \}\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "temp = "\cf0  + temp);\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "remain = "\cf0  + remain);\cb1 \
\cb3             ans = \cf44 temp\cf0 .\cf43 concat\cf0 (ans);\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "*************** i = "\cf0  + i + \cf46 " ***************"\cf0 );\cb1 \
\cb3         \}\cb1 \
\
\cb3         \cf45 return\cf0  ans;\cb1 \
\cb3     \}\cb1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \kerning1\expnd0\expndtw0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
44. Wildcard Matching
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0

\f6\b0\fs26 \cf26 public\cf0  \cf26 static\cf0  \cf42 boolean\cf0  \cf43 isMatch\cf0 (\cf42 String\cf0  \cf44 s\cf0 , \cf42 String\cf0  \cf44 p\cf0 ) \{\cb1 \
\cb3         \cf42 int\cf0  \cf44 i\cf0 =\cf29 0\cf0 , j=\cf29 0\cf0 ;\cb1 \
\cb3         \cf45 while\cf0  (i<\cf44 s\cf0 .\cf43 length\cf0 () && j<\cf44 p\cf0 .\cf43 length\cf0 ()) \{\cb1 \
\cb3             \cf45 if\cf0 (\cf44 s\cf0 .\cf43 charAt\cf0 (i) == \cf44 p\cf0 .\cf43 charAt\cf0 (j) || \cf44 p\cf0 .\cf43 charAt\cf0 (j) == \cf46 '?'\cf0 ) \{\cb1 \
\cb3                 i++;\cb1 \
\cb3                 j++;\cb1 \
\cb3             \} \cf45 else\cf0  \cf45 if\cf0 (\cf44 p\cf0 .\cf43 charAt\cf0 (j) == \cf46 '*'\cf0 ) \{\cb1 \
\cb3                 \cf45 if\cf0 (i == \cf29 0\cf0 )\cb1 \
\cb3                     i++;\cb1 \
\cb3                 \cf45 else\cf0  \cf45 if\cf0 (\cf44 s\cf0 .\cf43 charAt\cf0 (i) == \cf44 s\cf0 .\cf43 charAt\cf0 (i-\cf29 1\cf0 )) \{\cb1 \
\cb3                     i++;\cb1 \
\cb3                 \} \cf45 else\cf0  \{\cb1 \
\cb3                     j++;\cb1 \
\cb3                 \}\cb1 \
\cb3             \} \cf45 else\cf0 \cb1 \
\cb3                 \cf45 return\cf0  \cf26 false\cf0 ;\cb1 \
\cb3         \}\cb1 \
\
\cb3         \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (i);\cb1 \
\cb3         \cf45 return\cf0  i == \cf44 s\cf0 .\cf43 length\cf0 ();\cb1 \
\cb3     \}\
\pard\pardeftab720\partightenfactor0
\cf0 \cb1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \kerning1\expnd0\expndtw0 **********************************
\f6\fs26 \cf26 \cb3 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0
\cf26 public\cf0  \cf42 boolean\cf0  \cf43 isMatch\cf0 (\cf42 String\cf0  \cf44 str\cf0 , \cf42 String\cf0  \cf44 pattern\cf0 ) \{\cb1 \
\cb3         \cf42 int\cf0  \cf44 s\cf0  = \cf29 0\cf0 , p = \cf29 0\cf0 , match = \cf29 0\cf0 , starIdx = -\cf29 1\cf0 ;            \cb1 \
\cb3         \cf45 while\cf0  (s < \cf44 str\cf0 .\cf43 length\cf0 ())\{\cb1 \
\cb3             \cf28 // advancing both pointers\cf0 \cb1 \
\cb3             \cf45 if\cf0  (p < \cf44 pattern\cf0 .\cf43 length\cf0 ()  && (\cf44 pattern\cf0 .\cf43 charAt\cf0 (p) == \cf46 '?'\cf0  || \cf44 str\cf0 .\cf43 charAt\cf0 (s) == \cf44 pattern\cf0 .\cf43 charAt\cf0 (p)))\{\cb1 \
\cb3                 s++;\cb1 \
\cb3                 p++;\cb1 \
\cb3             \}\cb1 \
\cb3             \cf28 // * found, only advancing pattern pointer\cf0 \cb1 \
\cb3             \cf45 else\cf0  \cf45 if\cf0  (p < \cf44 pattern\cf0 .\cf43 length\cf0 () && \cf44 pattern\cf0 .\cf43 charAt\cf0 (p) == \cf46 '*'\cf0 )\{\cb1 \
\cb3                 starIdx = p;\cb1 \
\cb3                 match = s;\cb1 \
\cb3                 p++;\cb1 \
\cb3             \}\cb1 \
\cb3            \cf28 // last pattern pointer was *, advancing string pointer\cf0 \cb1 \
\cb3             \cf45 else\cf0  \cf45 if\cf0  (starIdx != -\cf29 1\cf0 )\{\cb1 \
\cb3                 p = starIdx + \cf29 1\cf0 ;\cb1 \
\cb3                 match++;\cb1 \
\cb3                 s = match;\cb1 \
\cb3             \}\cb1 \
\cb3            \cf28 // current pattern pointer is not star, last patter pointer was not *\cf0 \cb1 \
\cb3            \cf28 // characters do not match\cf0 \cb1 \
\cb3             \cf45 else\cf0  \cf45 return\cf0  \cf26 false\cf0 ;\cb1 \
\cb3         \}\cb1 \
\cb3         \cb1 \
\cb3         \cf28 // check the rest element in p, if all are *, true, else false;\cf0 \cb1 \
\cb3         \cf45 while\cf0  (p < \cf44 pattern\cf0 .\cf43 length\cf0 () && \cf44 pattern\cf0 .\cf43 charAt\cf0 (p) == \cf46 '*'\cf0 )\cb1 \
\cb3             p++;\cb1 \
\cb3         \cb1 \
\cb3         \cf45 return\cf0  p == \cf44 pattern\cf0 .\cf43 length\cf0 ();\cb1 \
\cb3     \}\cb1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \kerning1\expnd0\expndtw0 \
********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
45. Jump Game II
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f6\fs24 \cf19 private static void \cf20 backTrack\cf21 (\cf19 int \cf22 index\cf21 , \cf19 int \cf22 step\cf21 , \cf19 int\cf21 [] \cf22 nums\cf21 ) \{\
        \cf19 if\cf21 (\cf22 index \cf19 == \cf22 nums\cf21 .length\cf19 -\cf23 1\cf21 ) \{\
            \cf20 System\cf21 .
\f9\i \cf23 out
\f6\i0 \cf21 .\cf20 println\cf21 (\cf33 "Reach Goal : Step = " \cf19 + \cf22 step\cf21 );\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf24 //            step = step - 1;\
            \cf19 return\cf21 ;\
        \}\
\
        \cf19 for\cf21 (\cf19 int \cf23 i\cf19 =\cf22 index\cf21 ; \cf23 i\cf19 <\cf22 nums\cf21 .length; \cf23 i\cf19 ++\cf21 ) \{\
\cf24 //            List<Integer> myList = new ArrayList<>();\
            \cf19 int \cf23 j \cf19 = \cf23 0\cf21 ;\
            \cf19 while\cf21 (\cf23 j \cf19 <= \cf22 nums\cf21 [\cf23 i\cf21 ]) \{\
                \cf19 if\cf21 (\cf23 i\cf19 +\cf23 j \cf19 < \cf22 nums\cf21 .length \cf19 && \cf23 i\cf19 +\cf23 j \cf19 != \cf23 i\cf21 ) \{\
                    \cf23 i \cf19 = \cf23 i \cf19 + \cf23 j\cf21 ;\
                    
\f9\i \cf20 backTrack
\f6\i0 \cf21 (\cf23 i\cf21 , \cf19 ++\cf22 step\cf21 , \cf22 nums\cf21 );\
                    \cf23 i \cf19 = \cf23 i \cf19 - \cf23 j\cf21 ;\
                    \cf20 System\cf21 .
\f9\i \cf23 out
\f6\i0 \cf21 .\cf20 println\cf21 (\cf33 "i = " \cf19 + \cf23 i \cf19 + \cf33 ", j = " \cf19 + \cf23 j\cf21 );\
                    \cf20 System\cf21 .
\f9\i \cf23 out
\f6\i0 \cf21 .\cf20 println\cf21 (\cf33 "******* " \cf19 + \cf22 step \cf19 + \cf33 " ******"\cf21 );\
                    \cf22 step\cf19 --\cf21 ;\
                \}\
                \cf23 j\cf19 ++\cf21 ;\
            \}\
        \}\
    \}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \
********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
48. Rotate Image
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720\partightenfactor0

\f6\b0\fs26 \cf26 public\cf0  \cf42 void\cf0  \cf43 rotate\cf0 (\cf42 int\cf0 [][] \cf44 matrix\cf0 ) \{\cb1 \
\cb3         \cf42 int\cf0  \cf44 len\cf0  = \cf44 matrix\cf0 .\cf44 length\cf0 ;\cb1 \
\cb3         \cf45 if\cf0 (len == \cf29 1\cf0 ) \cf45 return\cf0 ;\cb1 \
\cb3         \cf42 boolean\cf0 [][] \cf44 check\cf0  = \cf45 new\cf0  \cf42 boolean\cf0 [len][len];\cb1 \
\
\cb3         \cf42 int\cf0  \cf44 i\cf0  = \cf29 0\cf0 , j = \cf29 0\cf0 ;\cb1 \
\cb3         \cf42 int\cf0  \cf44 val\cf0  = matrix[i][j]; \cb1 \
\
\cb3         \cf45 while\cf0 (!\cf43 checkAvailable\cf0 (check,len) && j < len) \{\cb1 \
\cb3             \cf42 int\cf0  \cf44 nextI\cf0  = j;\cb1 \
\cb3             \cf42 int\cf0  \cf44 nextJ\cf0  = len - i - \cf29 1\cf0 ;\cb1 \
\
\cb3             \cf42 int\cf0  \cf44 nextVal\cf0  = matrix[nextI][nextJ];\cb1 \
\cb3             matrix[nextI][nextJ] = val;\cb1 \
\cb3             \cf28 // change value of check\cf0 \cb1 \
\cb3             check[i][j] = \cf26 true\cf0 ;\cb1 \
\
\cb3             \cf45 while\cf0 (check[nextI][nextJ]) \{\cb1 \
\cb3                 \cf45 if\cf0 (nextJ == len - \cf29 1\cf0 ) \{\cb1 \
\cb3                     nextI++;\cb1 \
\cb3                     nextJ = \cf29 0\cf0 ;\cb1 \
\cb3                 \}\cb1 \
\cb3                 nextJ++;\cb1 \
\cb3                 nextVal = matrix[nextI][nextJ];\cb1 \
\cb3                 \cf45 if\cf0 (\cf43 checkAvailable\cf0 (check,len))\cb1 \
\cb3                     \cf45 break\cf0 ;\cb1 \
\cb3             \}\cb1 \
\cb3             val = nextVal;\cb1 \
\
\cb3             i = nextI;\cb1 \
\cb3             j = nextJ;\cb1 \
\cb3         \}\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 private\cf0  \cf26 static\cf0  \cf42 boolean\cf0  \cf43 checkAvailable\cf0 (\cf42 boolean\cf0 [][] \cf44 check\cf0 , \cf42 int\cf0  \cf44 len\cf0 ) \{\cb1 \
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 i\cf0 =\cf29 0\cf0 ; i<len; i++) \{\cb1 \
\cb3             \cf45 for\cf0 (\cf42 int\cf0  \cf44 j\cf0 =\cf29 0\cf0 ; j<len; j++) \{\cb1 \
\cb3                 \cf45 if\cf0 (!check[i][j])\cb1 \
\cb3                     \cf45 return\cf0  \cf26 false\cf0 ;\cb1 \
\cb3             \}\cb1 \
\cb3         \}\cb1 \
\cb3         \cf45 return\cf0  \cf26 true\cf0 ;\cb1 \
\cb3     \}\cb1 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs72 \cf0 \kerning1\expnd0\expndtw0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\b0\fs28 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
49. Group Anagrams
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f0\b\fs72 \
\pard\pardeftab720\partightenfactor0

\f6\b0\fs26 \cf26 \cb3 \expnd0\expndtw0\kerning0
public\cf0  \cf26 static\cf0  \cf42 List\cf0 <\cf42 List\cf0 <\cf42 String\cf0 >> \cf43 groupAnagrams\cf0 (\cf42 String\cf0 [] \cf44 strs\cf0 ) \{\cb1 \
\cb3         \cf42 List\cf0 <\cf42 String\cf0 > \cf44 innerList\cf0  = \cf45 new\cf0  \cf42 ArrayList\cf0 <>();\cb1 \
\cb3         \cf42 List\cf0 <\cf42 List\cf0 <\cf42 String\cf0 >> \cf44 result\cf0  = \cf45 new\cf0  \cf42 ArrayList\cf0 <>();\cb1 \
\
\cb3         \cf42 int\cf0  \cf44 elementCount\cf0  = \cf29 0\cf0 ;\cb1 \
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 i\cf0 =\cf29 0\cf0 ; i<\cf44 strs\cf0 .\cf44 length\cf0 ; i++) \{\cb1 \
\cb3             \cf42 List\cf0 <\cf42 String\cf0 > \cf44 containAlpha\cf0  = \cf45 new\cf0  \cf42 ArrayList\cf0 <>();\cb1 \
\cb3             \cf44 containAlpha\cf0 .\cf43 addAll\cf0 (\cf44 List\cf0 .\cf43 of\cf0 (strs[i].\cf43 split\cf0 (\cf46 ""\cf0 )));\cb1 \
\cb3             \cf42 String\cf0  \cf44 temp\cf0  = strs[i];\cb1 \
\cb3             \cf45 if\cf0 (!\cf44 result\cf0 .\cf43 stream\cf0 ().\cf43 anyMatch\cf0 (e \cf26 ->\cf0  \cf44 e\cf0 .\cf43 contains\cf0 (temp))) \{\cb1 \
\cb3                 \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (containAlpha + \cf46 " VS "\cf0  + temp);\cb1 \
\
\cb3                 innerList = \cf43 checkContainAlpha\cf0 (strs, i, containAlpha);\cb1 \
\cb3                 elementCount += \cf44 innerList\cf0 .\cf43 size\cf0 ();\cb1 \
\cb3                 \cf44 result\cf0 .\cf43 add\cf0 (innerList);\cb1 \
\cb3             \}\cb1 \
\
\cb3             \cf45 if\cf0 (elementCount == \cf44 strs\cf0 .\cf44 length\cf0 )\cb1 \
\cb3                 \cf45 break\cf0 ;\cb1 \
\
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "**********************************"\cf0 );\cb1 \
\cb3         \}\cb1 \
\
\cb3         \cf45 return\cf0  result;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 private\cf0  \cf26 static\cf0  \cf42 List\cf0 <\cf42 String\cf0 > \cf43 checkContainAlpha\cf0 (\cf42 String\cf0 [] \cf44 s\cf0 , \cf42 int\cf0  \cf44 index\cf0 , \cf42 List\cf0 <\cf42 String\cf0 > \cf44 model\cf0 ) \{\cb1 \
\cb3         \cf42 List\cf0 <\cf42 String\cf0 > \cf44 containModel\cf0  = \cf45 new\cf0  \cf42 ArrayList\cf0 <>();\cb1 \
\cb3         \cf44 containModel\cf0 .\cf43 add\cf0 (s[index]);\cb1 \
\cb3         \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "containModel = "\cf0  + containModel + \cf46 ", i = "\cf0  + index);\cb1 \
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 i\cf0 =index+\cf29 1\cf0 ; i<\cf44 s\cf0 .\cf44 length\cf0 ; i++) \{\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "compare string = "\cf0  + s[i]);\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "s[i-1] = "\cf0  + s[i-\cf29 1\cf0 ]);\cb1 \
\
\cb3             \cf45 if\cf0 (s[index].\cf43 equals\cf0 (\cf46 ""\cf0 ) && s[i].\cf43 equals\cf0 (s[index]) || s[i].\cf43 length\cf0 () == \cf44 model\cf0 .\cf43 size\cf0 () && \cf43 checkMatch\cf0 (s[i],model)) \{\cb1 \
\cb3                 \cf44 containModel\cf0 .\cf43 add\cf0 (s[i]);\cb1 \
\cb3             \}\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "*****************"\cf0 );\cb1 \
\cb3         \}\cb1 \
\
\cb3         \cf45 return\cf0  containModel;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 private\cf0  \cf26 static\cf0  \cf42 boolean\cf0  \cf43 checkMatch\cf0 (\cf42 String\cf0  \cf44 currentString\cf0 , \cf42 List\cf0 <\cf42 String\cf0 > \cf44 model\cf0 ) \{\cb1 \
\cb3         \cf42 List\cf0 <\cf42 String\cf0 > \cf44 copyModel\cf0  = \cf45 new\cf0  \cf42 ArrayList\cf0 <>(model);\cb1 \
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 i\cf0  = \cf29 0\cf0 ; i< \cf44 currentString\cf0 .\cf43 length\cf0 (); i++) \{\cb1 \
\cb3             \cf45 if\cf0 (!\cf44 copyModel\cf0 .\cf43 contains\cf0 (\cf44 String\cf0 .\cf43 valueOf\cf0 (\cf44 currentString\cf0 .\cf43 charAt\cf0 (i)))) \{\cb1 \
\cb3                 \cf45 return\cf0  \cf26 false\cf0 ;\cb1 \
\cb3             \}\cb1 \
\cb3             \cf44 copyModel\cf0 .\cf43 remove\cf0 (\cf44 String\cf0 .\cf43 valueOf\cf0 (\cf44 currentString\cf0 .\cf43 charAt\cf0 (i)));\cb1 \
\cb3         \}\cb1 \
\pard\pardeftab720\partightenfactor0
\cf28 \cb3 //        System.out.println(currentString + " : " + model);\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3         \cf45 return\cf0  \cf26 true\cf0 ;\cb1 \
\cb3     \}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 *******************************************\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f6\fs26 \cf0 \cb3 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0
\cf26 public\cf0  \cf42 List\cf0 <\cf42 List\cf0 <\cf42 String\cf0 >> \cf43 groupAnagrams\cf0 (\cf42 String\cf0 [] \cf44 strs\cf0 ) \{\cb1 \
\cb3         \cf42 List\cf0 <\cf42 List\cf0 <\cf42 String\cf0 >> \cf44 result\cf0  = \cf45 new\cf0  \cf42 ArrayList\cf0 <>();\cb1 \
\cb3         \cf42 List\cf0 <\cf42 String\cf0 > \cf44 addedString\cf0  = \cf45 new\cf0  \cf42 ArrayList\cf0 <>();\cb1 \
\
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 i\cf0 =\cf29 0\cf0 ; i<\cf44 strs\cf0 .\cf44 length\cf0 ; i++) \{\cb1 \
\cb3             \cf42 List\cf0 <\cf42 String\cf0 > \cf44 innerList\cf0  = \cf45 new\cf0  \cf42 ArrayList\cf0 <>();\cb1 \
\
\cb3             \cf45 if\cf0 (\cf44 addedString\cf0 .\cf43 contains\cf0 (strs[i])) \{\cb1 \
\cb3                 \cf45 continue\cf0 ;\cb1 \
\cb3             \}\cb1 \
\
\cb3             \cf44 innerList\cf0 .\cf43 add\cf0 (strs[i]);\cb1 \
\cb3             \cf44 addedString\cf0 .\cf43 add\cf0 (strs[i]);\cb1 \
\cb3             \cf45 for\cf0 (\cf42 int\cf0  \cf44 j\cf0 =i+\cf29 1\cf0 ; j<\cf44 strs\cf0 .\cf44 length\cf0 ; j++) \{\cb1 \
\cb3                 \cf42 String\cf0  \cf44 temp\cf0  = strs[j];\cb1 \
\cb3                 \cf45 if\cf0 (\cf44 temp\cf0 .\cf43 isEmpty\cf0 () && strs[i].\cf43 equals\cf0 (temp)) \{\cb1 \
\cb3                     \cf44 innerList\cf0 .\cf43 add\cf0 (temp);\cb1 \
\cb3                     \cf44 addedString\cf0 .\cf43 add\cf0 (temp);\cb1 \
\cb3                     \cf45 continue\cf0 ;\cb1 \
\cb3                 \}\cb1 \
\cb3                 \cf45 if\cf0 (strs[i].\cf43 equals\cf0 (temp) || !\cf44 addedString\cf0 .\cf43 contains\cf0 (temp)) \{\cb1 \
\cb3                     \cf45 if\cf0 (strs[i].\cf43 length\cf0 () == \cf44 temp\cf0 .\cf43 length\cf0 () && \cf43 isAnagrams\cf0 (strs[i], temp)) \{\cb1 \
\cb3                         \cf44 innerList\cf0 .\cf43 add\cf0 (temp);\cb1 \
\cb3                         \cf44 addedString\cf0 .\cf43 add\cf0 (temp);\cb1 \
\cb3                     \}\cb1 \
\cb3                 \}\cb1 \
\cb3             \}\cb1 \
\cb3             \cf44 result\cf0 .\cf43 add\cf0 (innerList);\cb1 \
\cb3             \cf45 if\cf0 (\cf44 innerList\cf0 .\cf43 size\cf0 () == \cf44 strs\cf0 .\cf44 length\cf0 ) \{\cb1 \
\cb3                 \cf45 break\cf0 ;\cb1 \
\cb3             \}\cb1 \
\cb3         \}\cb1 \
\
\cb3         \cf45 return\cf0  result;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 private\cf0  \cf42 boolean\cf0  \cf43 isAnagrams\cf0 (\cf42 String\cf0  \cf44 mainStr\cf0 , \cf42 String\cf0  \cf44 compStr\cf0 ) \{\cb1 \
\cb3         \cf42 List\cf0 <\cf42 Character\cf0 > \cf44 splitStr\cf0  = \cf44 mainStr\cf0 .\cf43 chars\cf0 ().\cf43 mapToObj\cf0 (e \cf26 ->\cf0  (\cf42 char\cf0 ) e).\cf43 collect\cf0 (\cf44 Collectors\cf0 .\cf43 toList\cf0 ());\cb1 \
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 i\cf0 =\cf29 0\cf0 ; i<\cf44 compStr\cf0 .\cf43 length\cf0 (); i++) \{\cb1 \
\cb3             \cf42 Character\cf0  \cf44 curChar\cf0  = \cf44 compStr\cf0 .\cf43 charAt\cf0 (i);\cb1 \
\cb3             \cf45 if\cf0 (!\cf44 splitStr\cf0 .\cf43 contains\cf0 (curChar)) \{\cb1 \
\cb3                 \cf45 return\cf0  \cf26 false\cf0 ;\cb1 \
\cb3             \}\cb1 \
\cb3             \cf44 splitStr\cf0 .\cf43 remove\cf0 (curChar);\cb1 \
\cb3         \}\cb1 \
\cb3         \cf45 return\cf0  \cf44 splitStr\cf0 .\cf43 size\cf0 () == \cf29 0\cf0 ;\cb1 \
\cb3     \}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs72 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\b0\fs28 \cf0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
56. Merge Intervals
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f6\fs26 \cb3 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0
\cf0 \cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf26 \cb3 public\cf0  \cf26 static\cf0  \cf42 int\cf0 [][] \cf43 merge\cf0 (\cf42 int\cf0 [][] \cf44 intervals\cf0 ) \{\cb1 \
\cb3         \cf45 if\cf0 (\cf44 intervals\cf0 .\cf44 length\cf0  <= \cf29 1\cf0 ) \cf45 return\cf0  intervals;\cb1 \
\
\cb3         \cf42 List\cf0 <\cf42 Integer\cf0 > \cf44 myList\cf0  = \cf45 new\cf0  \cf42 ArrayList\cf0 <>();\cb1 \
\cb3         \cf44 myList\cf0 .\cf43 add\cf0 (intervals[\cf29 0\cf0 ][\cf29 0\cf0 ]);\cb1 \
\cb3         \cf42 int\cf0  \cf44 currentVal\cf0  = intervals[\cf29 0\cf0 ][\cf29 1\cf0 ];\cb1 \
\
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 i\cf0 =\cf29 1\cf0 ; i<\cf44 intervals\cf0 .\cf44 length\cf0 ; i++) \{\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "Check Array -> "\cf0  + \cf44 Arrays\cf0 .\cf43 toString\cf0 (intervals[i]));\cb1 \
\
\cb3             \cf45 if\cf0 (\cf44 myList\cf0 .\cf43 size\cf0 () % \cf29 2\cf0  == \cf29 0\cf0 ) \{\cb1 \
\cb3                 \cf44 myList\cf0 .\cf43 add\cf0 (intervals[i][\cf29 0\cf0 ]);\cb1 \
\cb3             \}\cb1 \
\
\cb3             \cf45 if\cf0 (currentVal > intervals[i][\cf29 0\cf0 ]) \{\cb1 \
\cb3                 \cf45 if\cf0 (currentVal <= intervals[i][\cf29 1\cf0 ]) \{\cb1 \
\cb3                     \cf44 myList\cf0 .\cf43 add\cf0 (intervals[i][\cf29 1\cf0 ]);\cb1 \
\cb3                     \cf45 if\cf0 (i<\cf44 intervals\cf0 .\cf44 length\cf0 -\cf29 1\cf0 )\cb1 \
\cb3                         currentVal = intervals[i+\cf29 1\cf0 ][\cf29 1\cf0 ];\cb1 \
\cb3                 \} \cf45 else\cf0  \{\cb1 \
\cb3                     \cf45 if\cf0 (i==\cf44 intervals\cf0 .\cf44 length\cf0 -\cf29 1\cf0 )\cb1 \
\cb3                         \cf44 myList\cf0 .\cf43 add\cf0 (currentVal);\cb1 \
\cb3                 \}\cb1 \
\cb3             \} \cf45 else\cf0  \{\cb1 \
\cb3                 \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (currentVal + \cf46 " : "\cf0  + intervals[i][\cf29 1\cf0 ]);\cb1 \
\cb3                 \cf44 myList\cf0 .\cf43 add\cf0 (currentVal);\cb1 \
\cb3                 currentVal = intervals[i][\cf29 1\cf0 ];\cb1 \
\cb3             \}\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "CurrentList -> "\cf0  + myList);\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "*******************************"\cf0 );\cb1 \
\cb3         \}\cb1 \
\
\
\cb3         \cf42 int\cf0  \cf44 len\cf0  = \cf44 myList\cf0 .\cf43 size\cf0 ()/\cf29 2\cf0 ;\cb1 \
\cb3         \cf42 int\cf0  \cf44 index\cf0  = \cf29 0\cf0 ;\cb1 \
\cb3         \cf42 int\cf0 [][] \cf44 result\cf0  = \cf45 new\cf0  \cf42 int\cf0 [len][\cf29 2\cf0 ];\cb1 \
\cb3         \cf45 for\cf0 (\cf42 int\cf0  \cf44 i\cf0 =\cf29 0\cf0 ; i<len && index<\cf44 myList\cf0 .\cf43 size\cf0 (); i++) \{\cb1 \
\cb3             \cf45 for\cf0 (\cf42 int\cf0  \cf44 j\cf0 =\cf29 0\cf0 ; j<\cf29 2\cf0 ; j++) \{\cb1 \
\cb3                 result[i][j] = \cf44 myList\cf0 .\cf43 get\cf0 (index++);\cb1 \
\cb3             \}\cb1 \
\cb3         \}\cb1 \
\
\cb3         \cf45 return\cf0  result;\cb1 \
\cb3     \}\cb1 \
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \kerning1\expnd0\expndtw0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
57. Insert Intervals
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************\
\pard\pardeftab720\partightenfactor0

\f6\fs26 \cf35 \expnd0\expndtw0\kerning0
public\cf0  \cf35 int\cf37 [][]\cf0  \cf36 insert\cf37 (\cf35 int\cf37 [][]\cf0  intervals\cf37 ,\cf0  \cf35 int\cf37 []\cf0  newInterval\cf37 )\cf0  \cf37 \{\cf0 \
        \cf36 List\cf38 \cb39 <\cf35 \cb1 int\cf37 []\cf38 \cb39 >\cf0 \cb1  ans \cf38 \cb39 =\cf0 \cb1  \cf35 new\cf0  \cf36 ArrayList\cf37 <>();\cf0 \
        \cf35 int\cf0  st \cf38 \cb39 =\cf0 \cb1  newInterval\cf37 [\cf40 0\cf37 ],\cf0  ed \cf38 \cb39 =\cf0 \cb1  newInterval\cf37 [\cf40 1\cf37 ];\cf0 \
        \cf35 boolean\cf0  insert \cf38 \cb39 =\cf0 \cb1  \cf40 false\cf37 ;\cf0 \
        \cf35 for\cf0  \cf37 (\cf35 int\cf37 []\cf0  interval \cf38 \cb39 :\cf0 \cb1  intervals\cf37 )\cf0  \cf37 \{\cf0 \
            \cf35 int\cf0  s \cf38 \cb39 =\cf0 \cb1  interval\cf37 [\cf40 0\cf37 ],\cf0  e \cf38 \cb39 =\cf0 \cb1  interval\cf37 [\cf40 1\cf37 ];\cf0 \
            \cf35 if\cf0  \cf37 (\cf0 ed \cf38 \cb39 <\cf0 \cb1  s\cf37 )\cf0  \cf37 \{\cf0 \
                \cf35 if\cf0  \cf37 (\cf38 \cb39 !\cf0 \cb1 insert\cf37 )\cf0  \cf37 \{\cf0 \
                    ans\cf37 .\cf36 add\cf37 (\cf35 new\cf0  \cf35 int\cf37 []\cf0  \cf37 \{\cf0 st\cf37 ,\cf0  ed\cf37 \});\cf0 \
                    insert \cf38 \cb39 =\cf0 \cb1  \cf40 true\cf37 ;\cf0 \
                \cf37 \}\cf0 \
                ans\cf37 .\cf36 add\cf37 (\cf0 interval\cf37 );\cf0 \
            \cf37 \}\cf0  \cf35 else\cf0  \cf35 if\cf0  \cf37 (\cf0 e \cf38 \cb39 <\cf0 \cb1  st\cf37 )\cf0  \cf37 \{\cf0 \
                ans\cf37 .\cf36 add\cf37 (\cf0 interval\cf37 );\cf0 \
            \cf37 \}\cf0  \cf35 else\cf0  \cf37 \{\cf0 \
                st \cf38 \cb39 =\cf0 \cb1  \cf36 Math\cf37 .\cf36 min\cf37 (\cf0 st\cf37 ,\cf0  s\cf37 );\cf0 \
                ed \cf38 \cb39 =\cf0 \cb1  \cf36 Math\cf37 .\cf36 max\cf37 (\cf0 ed\cf37 ,\cf0  e\cf37 );\cf0 \
            \cf37 \}\cf0 \
        \cf37 \}\cf0 \
        \cf35 if\cf0  \cf37 (\cf38 \cb39 !\cf0 \cb1 insert\cf37 )\cf0  \cf37 \{\cf0 \
            ans\cf37 .\cf36 add\cf37 (\cf35 new\cf0  \cf35 int\cf37 []\cf0  \cf37 \{\cf0 st\cf37 ,\cf0  ed\cf37 \});\cf0 \
        \cf37 \}\cf0 \
        \cf35 return\cf0  ans\cf37 .\cf36 toArray\cf37 (\cf35 new\cf0  \cf35 int\cf37 [\cf0 ans\cf37 .\cf36 size\cf37 ()][]);\cf0 \
    \cf37 \}\
\cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \kerning1\expnd0\expndtw0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
57. Merge Sorted Array
\f1\b0\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************\
\
\pard\pardeftab720\partightenfactor0

\f6\fs26 \cf26 \cb3 \expnd0\expndtw0\kerning0
public\cf0  \cf42 void\cf0  \cf43 merge\cf0 (\cf42 int\cf0 [] \cf44 nums1\cf0 , \cf42 int\cf0  \cf44 m\cf0 , \cf42 int\cf0 [] \cf44 nums2\cf0 , \cf42 int\cf0  \cf44 n\cf0 ) \{\cb1 \
\cb3         \cf42 int\cf0  \cf44 i\cf0  = \cf29 0\cf0 ; \cf28 // i < m\cf0 \cb1 \
\cb3         \cf42 int\cf0  \cf44 j\cf0  = \cf29 0\cf0 ; \cf28 // j < n\cf0 \cb1 \
\cb3         \cf42 Queue\cf0 <\cf42 Integer\cf0 > \cf44 store\cf0  = \cf45 new\cf0  \cf42 ArrayDeque\cf0 <>();\cb1 \
\
\cb3         \cf45 while\cf0 (i < m && j < n) \{\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "i="\cf0  + i + \cf46 ", j="\cf0  + j);\cb1 \
\cb3             \cf45 if\cf0 (i>\cf29 0\cf0  && nums1[i] == \cf29 0\cf0  && nums1[i-\cf29 1\cf0 ] > nums1[i]) \{\cb1 \
\cb3                 \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "out loop"\cf0 );\cb1 \
\cb3                 \cf45 break\cf0 ;\cb1 \
\cb3             \}\cb1 \
\
\cb3             \cf45 if\cf0 (nums1[i] <= nums2[j]) \{\cb1 \
\cb3                 \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "First"\cf0 );\cb1 \
\cb3                 i++;\cb1 \
\cb3             \} \cf45 else\cf0  \{\cb1 \
\cb3                 \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "Second"\cf0 );\cb1 \
\cb3                 \cf45 if\cf0 (\cf44 store\cf0 .\cf43 isEmpty\cf0 ()) \{\cb1 \
\cb3                     \cf44 store\cf0 .\cf43 add\cf0 (nums1[i]);\cb1 \
\cb3                     nums1[i] = nums2[j];\cb1 \
\cb3                     i++;\cb1 \
\cb3                     j++;\cb1 \
\cb3                 \} \cf45 else\cf0  \{\cb1 \
\cb3                     \cf45 if\cf0 (nums2[j] > \cf44 store\cf0 .\cf43 peek\cf0 ()) \{\cb1 \
\cb3                         nums1[i] = \cf44 store\cf0 .\cf43 remove\cf0 ();\cb1 \
\cb3                     \} \cf45 else\cf0  \{\cb1 \
\cb3                         nums1[i] = nums2[j];\cb1 \
\cb3                         j++;\cb1 \
\cb3                     \}\cb1 \
\cb3                     i++;\cb1 \
\cb3                 \}\cb1 \
\cb3             \}\cb1 \
\cb3             \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (\cf46 "************************************"\cf0 );\cb1 \
\cb3         \}\cb1 \
\
\cb3         \cf44 System\cf0 .\cf44 out\cf0 .\cf43 println\cf0 (i + \cf46 " : "\cf0  + j);\cb1 \
\cb3         \cf45 while\cf0 (j < n && !\cf44 store\cf0 .\cf43 isEmpty\cf0 ()) \{\cb1 \
\cb3             \cf45 if\cf0 (nums2[j] > \cf44 store\cf0 .\cf43 peek\cf0 ()) \{\cb1 \
\cb3                 nums1[i] = \cf44 store\cf0 .\cf43 remove\cf0 ();\cb1 \
\cb3             \} \cf45 else\cf0  \{\cb1 \
\cb3                 nums1[i] = nums2[j];\cb1 \
\cb3                 j++;\cb1 \
\cb3             \}\cb1 \
\cb3             i++;\cb1 \
\cb3         \}\cb1 \
\cb3     \}\cb1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\partightenfactor0
\cf46 \cb3 *************************\cf0 \cb1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\partightenfactor0
\cf26 \cb3 \outl0\strokewidth0 \strokec26 public\cf0 \strokec47  \cf48 \strokec48 void\cf0 \strokec47  \cf49 \strokec49 merge\cf0 \strokec47 (\cf48 \strokec48 int\cf0 \strokec47 [] \cf50 \strokec50 nums1\cf0 \strokec47 , \cf48 \strokec48 int\cf0 \strokec47  \cf50 \strokec50 m\cf0 \strokec47 , \cf48 \strokec48 int\cf0 \strokec47 [] \cf50 \strokec50 nums2\cf0 \strokec47 , \cf48 \strokec48 int\cf0 \strokec47  \cf50 \strokec50 n\cf0 \strokec47 ) \{\cb1 \
\cb3         \cf48 \strokec48 int\cf0 \strokec47  \cf50 \strokec50 i\cf0 \strokec47  = \cf51 \strokec51 0\cf0 \strokec47 ; \cf52 \strokec52 // i < m\cf0 \cb1 \strokec47 \
\cb3         \cf48 \strokec48 int\cf0 \strokec47  \cf50 \strokec50 j\cf0 \strokec47  = \cf51 \strokec51 0\cf0 \strokec47 ; \cf52 \strokec52 // j < n\cf0 \cb1 \strokec47 \
\cb3         \cf48 \strokec48 List\cf0 \strokec47 <\cf48 \strokec48 Integer\cf0 \strokec47 > \cf50 \strokec50 store\cf0 \strokec47  = \cf53 \strokec53 new\cf0 \strokec47  \cf48 \strokec48 ArrayList\cf0 \strokec47 <>();\cb1 \
\
\cb3         \cf53 \strokec53 while\cf0 \strokec47 (\cf50 \strokec50 store\cf0 \strokec47 .\cf49 \strokec49 size\cf0 \strokec47 () < m) \{\cb1 \
\cb3             \cf53 \strokec53 if\cf0 \strokec47 (i > \cf51 \strokec51 0\cf0 \strokec47  && nums1[i-\cf51 \strokec51 1\cf0 \strokec47 ] > nums1[i] || j >= n)\cb1 \
\cb3                 \cf53 \strokec53 break\cf0 \strokec47 ;\cb1 \
\
\cb3             \cf53 \strokec53 if\cf0 \strokec47 (nums1[i] <= nums2[j]) \{\cb1 \
\cb3                 \cf50 \strokec50 store\cf0 \strokec47 .\cf49 \strokec49 add\cf0 \strokec47 (nums1[i]);\cb1 \
\cb3                 i++;\cb1 \
\cb3             \} \cf53 \strokec53 else\cf0 \strokec47  \{\cb1 \
\cb3                 \cf50 \strokec50 store\cf0 \strokec47 .\cf49 \strokec49 add\cf0 \strokec47 (nums2[j]);\cb1 \
\cb3                 j++;\cb1 \
\cb3             \}\cb1 \
\cb3         \}\cb1 \
\cb3         \cf53 \strokec53 if\cf0 \strokec47 (j>=n) \{\cb1 \
\cb3             \cf53 \strokec53 while\cf0 \strokec47 (\cf50 \strokec50 store\cf0 \strokec47 .\cf49 \strokec49 size\cf0 \strokec47 () < m) \{\cb1 \
\cb3                 \cf50 \strokec50 store\cf0 \strokec47 .\cf49 \strokec49 add\cf0 \strokec47 (nums1[i++]);\cb1 \
\cb3             \}\cb1 \
\cb3         \} \cf53 \strokec53 else\cf0 \strokec47  \{\cb1 \
\cb3             \cf53 \strokec53 while\cf0 \strokec47 (\cf50 \strokec50 store\cf0 \strokec47 .\cf49 \strokec49 size\cf0 \strokec47 () < m) \{\cb1 \
\cb3                 \cf50 \strokec50 store\cf0 \strokec47 .\cf49 \strokec49 add\cf0 \strokec47 (nums2[j++]);\cb1 \
\cb3             \}\cb1 \
\cb3         \}\cb1 \
\cb3         \cf53 \strokec53 for\cf0 \strokec47 (\cf48 \strokec48 int\cf0 \strokec47  \cf50 \strokec50 k\cf0 \strokec47 =\cf51 \strokec51 0\cf0 \strokec47 ; k<m; k++) \{\cb1 \
\cb3             nums1[k] = \cf50 \strokec50 store\cf0 \strokec47 .\cf49 \strokec49 get\cf0 \strokec47 (k);\cb1 \
\cb3         \}\cb1 \
\cb3     \}\cb1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \outl0\strokewidth0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \kerning1\expnd0\expndtw0 ********************************************************************************************************\

\f2\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
155. Min Stack\

\f7\b0\fs30 Use one stack
\f1\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
********************************************************************************************************
\f6\fs26 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720\partightenfactor0
\cf48 \cb3 \outl0\strokewidth0 \strokec48 int\cf0 \strokec47  \cf50 \strokec50 min\cf0 \strokec47  = \cf50 \strokec50 Integer\cf0 \strokec47 .\cf50 \strokec50 MAX_VALUE\cf0 \strokec47 ;\cb1 \
\cb3     \cf48 \strokec48 Stack\cf0 \strokec47 <\cf48 \strokec48 Integer\cf0 \strokec47 > \cf50 \strokec50 stack\cf0 \strokec47  = \cf53 \strokec53 new\cf0 \strokec47  \cf48 \strokec48 Stack\cf0 \strokec47 <\cf48 \strokec48 Integer\cf0 \strokec47 >();\cb1 \
\cb3     \cf26 \strokec26 public\cf0 \strokec47  \cf48 \strokec48 void\cf0 \strokec47  \cf49 \strokec49 push\cf0 \strokec47 (\cf48 \strokec48 int\cf0 \strokec47  \cf50 \strokec50 x\cf0 \strokec47 ) \{\cb1 \
\cb3         \cf52 \strokec52 // only push the old minimum value when the current \cf0 \cb1 \strokec47 \
\cb3         \cf52 \strokec52 // minimum value changes after pushing the new value x\cf0 \cb1 \strokec47 \
\cb3         \cf53 \strokec53 if\cf0 \strokec47 (x <= min)\{          \cb1 \
\cb3             \cf50 \strokec50 stack\cf0 \strokec47 .\cf49 \strokec49 push\cf0 \strokec47 (min);\cb1 \
\cb3             min=x;\cb1 \
\cb3         \}\cb1 \
\cb3         \cf50 \strokec50 stack\cf0 \strokec47 .\cf49 \strokec49 push\cf0 \strokec47 (x);\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 \strokec26 public\cf0 \strokec47  \cf48 \strokec48 void\cf0 \strokec47  \cf49 \strokec49 pop\cf0 \strokec47 () \{\cb1 \
\cb3         \cf52 \strokec52 // if pop operation could result in the changing of the current minimum value, \cf0 \cb1 \strokec47 \
\cb3         \cf52 \strokec52 // pop twice and change the current minimum value to the last minimum value.\cf0 \cb1 \strokec47 \
\cb3         \cf53 \strokec53 if\cf0 \strokec47 (\cf50 \strokec50 stack\cf0 \strokec47 .\cf49 \strokec49 pop\cf0 \strokec47 () == min) min=\cf50 \strokec50 stack\cf0 \strokec47 .\cf49 \strokec49 pop\cf0 \strokec47 ();\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 \strokec26 public\cf0 \strokec47  \cf48 \strokec48 int\cf0 \strokec47  \cf49 \strokec49 top\cf0 \strokec47 () \{\cb1 \
\cb3         \cf53 \strokec53 return\cf0 \strokec47  \cf50 \strokec50 stack\cf0 \strokec47 .\cf49 \strokec49 peek\cf0 \strokec47 ();\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf26 \strokec26 public\cf0 \strokec47  \cf48 \strokec48 int\cf0 \strokec47  \cf49 \strokec49 getMin\cf0 \strokec47 () \{\cb1 \
\cb3         \cf53 \strokec53 return\cf0 \strokec47  min;\cb1 \
\cb3     \}\cb1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \outl0\strokewidth0 \
}